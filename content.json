{"meta":{"title":"Nonoka's Blog","subtitle":"","description":"Hello World!","author":"NogiNonoka","url":"https://noginonoka.github.io","root":"/"},"pages":[{"title":"Tags","date":"2021-01-19T13:29:40.719Z","updated":"2021-01-19T13:29:40.719Z","comments":false,"path":"tags/index.html","permalink":"https://noginonoka.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2021-01-19T13:30:45.085Z","updated":"2021-01-19T13:30:45.085Z","comments":false,"path":"about/index.html","permalink":"https://noginonoka.github.io/about/index.html","excerpt":"","text":"CS Student ACM Newbie"},{"title":"Categories","date":"2021-01-19T13:29:28.821Z","updated":"2021-01-19T13:29:28.821Z","comments":false,"path":"categories/index.html","permalink":"https://noginonoka.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Codeforces Round #703 (Rated for Div. 2)","slug":"Codeforces-Round-703-Rated-for-Div-2","date":"2021-02-19T14:26:37.000Z","updated":"2021-02-19T17:12:33.208Z","comments":true,"path":"2021/02/19/Codeforces-Round-703-Rated-for-Div-2/","link":"","permalink":"https://noginonoka.github.io/2021/02/19/Codeforces-Round-703-Rated-for-Div-2/","excerpt":"","text":"1486A - Shifting Stacks Analysis 贪心 注意只能从左向右移动。 1486B - Eastern Exhibition Problem 二维平面上 nnn 个点，求到其他 nnn 个点曼哈顿距离和最小的点的个数。 Analysis 计算几何 曼哈顿距离：x yx \\ yx y 坐标轴上的中位数； 欧氏距离：三分套三分。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl &quot;\\n&quot;const int MAXN = 1e3 + 7;int T;int n;int posx[MAXN];int posy[MAXN];int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; posx[i] &gt;&gt; posy[i]; &#125; sort(posx + 1, posx + n + 1); sort(posy + 1, posy + n + 1); if (n &amp; 1) &#123; int ansx = posx[n / 2 + 1]; int ansy = posy[n / 2 + 1]; int ans = 1; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; int ansx1 = posx[n / 2], ansx2 = posx[n / 2 + 1]; int ansy1 = posy[n / 2], ansy2 = posy[n / 2 + 1]; int ans = (ansx2 - ansx1 + 1) * (ansy2 - ansy1 + 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 1486C1/C2 - Guessing the Greatest Problem 交互题 询问：区间 [l, r][l ,\\ r][l, r] 范围内，第二大数的位置 pospospos； 求区间最大数的位置。 Analysis 二分查找 C1：首先询问区间 [l, r][l ,\\ r][l, r] 得到第二大数的位置 pospospos，询问 [l, mid](pos≤mid)[l ,\\ mid] (pos \\le mid)[l, mid](pos≤mid) 或 [mid, r](pos&gt;mid)[mid ,\\ r] (pos &gt; mid)[mid, r](pos&gt;mid)，若第二大数仍为 pospospos，则最大数在此区间内。 C2：查询区间 [1, pos][1 ,\\ pos][1, pos] 判断最大值在左区间或右区间，假设在右区间，二分查找最小的 pos′pos&#x27;pos′ 使得 [pos, pos′][pos ,\\ pos&#x27;][pos, pos′] 上第二大的数为 pospospos 此时 最大数在 pos′pos&#x27;pos′。 Code C1 - Easy Version 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int n;void query(int l, int r)&#123; cout &lt;&lt; &quot;? &quot; &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;&#125;void solve(int x)&#123; cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; endl;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; int l = 1, r = n; int pos; query(l ,r); cin &gt;&gt; pos; bool flg = false; int cnt = 1; while (cnt &lt;= 40) &#123; if (l == r) &#123; solve(l); break; &#125; if (l + 1 == r) &#123; solve((pos == l ? r : l)); break; &#125; int mid = (l + r) / 2; if (mid &gt;= pos) query(l, mid); else query(mid, r); ++cnt; int pos1; cin &gt;&gt; pos1; if (pos1 != pos) &#123; if (mid &gt;= pos) l = mid + 1; else r = mid - 1; if (l == r) continue; query(l, r); ++cnt; cin &gt;&gt; pos; &#125; else &#123; if (mid &gt;= pos) r = mid; else l = mid; &#125; &#125; return 0;&#125; C2 - Hard Version (Official) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;int ask(int l, int r) &#123; if (l &gt;= r) return -1; cout &lt;&lt; &quot;? &quot; &lt;&lt; l + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; r + 1 &lt;&lt; endl; int ans; cin &gt;&gt; ans; return ans - 1;&#125;int main() &#123; int n; cin &gt;&gt; n; int smax = ask(0, n - 1); if (smax == 0 || ask(0, smax) != smax) &#123; int l = smax, r = n - 1; while (r - l &gt; 1) &#123; int m = (l + r) / 2; if (ask(smax, m) == smax) &#123; r = m; &#125; else &#123; l = m; &#125; &#125; cout &lt;&lt; &quot;! &quot; &lt;&lt; r + 1 &lt;&lt; endl; &#125; else &#123; int l = 0, r = smax; while (r - l &gt; 1) &#123; int m = (l + r) / 2; if (ask(m, smax) == smax) &#123; l = m; &#125; else &#123; r = m; &#125; &#125; cout &lt;&lt; &quot;! &quot; &lt;&lt; l + 1 &lt;&lt; endl; &#125; return 0;&#125; 1486D - Max Median Problem 给定长度为 nnn 的序列 aaa； 区间长度不小于 kkk 的子序列 a[l, r]a[l ,\\ r]a[l, r]，对子序列排序后，询问 a⌊len+12⌋a_{\\lfloor \\frac{len + 1}{2} \\rfloor}a⌊2len+1​⌋​ 处值的最大值； Analysis 二分答案 求最大值的问题在答案可行性上具有单调性，故可以二分答案。 考虑对原序列转化，对于给定的： ai&lt;x, ai→−1ai≥x, ai→1\\begin{array}{c} a_i &lt; x ,\\ a_i \\rightarrow -1 \\\\ a_i \\ge x ,\\ a_i \\rightarrow 1 \\end{array} ai​&lt;x, ai​→−1ai​≥x, ai​→1​ 问题转化为，是否存在长度不小于 kkk 的区间，区间中 111 的个数不小于 −1-1−1 的个数； 使用前缀和维护问题，区间 111 与 −1-1−1的个数可以使用前缀和维护，记录前缀和最小位置； Code 注意二分端点与二分的循环条件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2e5 + 7;int n, k;int a[MAXN];int b[MAXN];int pre[MAXN];void change(int x)&#123; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] &lt; x) b[i] = -1; else b[i] = 1; &#125;&#125;bool check()&#123; pre[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; pre[i] = pre[i - 1] + b[i]; &#125; int mini = 0; for (int i = k; i &lt;= n; ++i) &#123; mini = min(mini, pre[i - k]); if (pre[i] - mini &gt; 0) return true; &#125; return false;&#125;void solve()&#123; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; int l = 0, r = n + 1; while (l + 1 &lt; r) &#123; int mid = (l + r) / 2; change(mid); if (check()) l = mid; else r = mid; &#125; cout &lt;&lt; l &lt;&lt; endl;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); solve(); return 0;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"}]},{"title":"Educational Codeforces Round 104 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-104-Rated-for-Div-2","date":"2021-02-19T03:07:15.000Z","updated":"2021-02-19T03:10:39.178Z","comments":true,"path":"2021/02/19/Educational-Codeforces-Round-104-Rated-for-Div-2/","link":"","permalink":"https://noginonoka.github.io/2021/02/19/Educational-Codeforces-Round-104-Rated-for-Div-2/","excerpt":"","text":"Educational Codeforces Round 104 (Rated for Div. 2) 1487A - Arena Analysis 贪心 排序 排序后，求非最小元素个数。 1487B - Cat Cycle Analysis 打表 思维 打表找规律。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &quot;\\n&quot;int T;int n, k;int geta(int x)&#123; return n - (x - 1) % n;&#125;int getb(int x, int t)&#123; return ((x - 1) % n + t) % n + 1;&#125;void brute()&#123; int cnt = 0; for (int i = 1; i &lt;= k; ++i) &#123; if (geta(i) == getb(i, cnt)) &#123; ++cnt; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; geta(i) &lt;&lt; endl; // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; geta(i) &lt;&lt; &quot; &quot; &lt;&lt; getb(i, cnt) &lt;&lt; endl; &#125; // else // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; geta(i) &lt;&lt; &quot; &quot; &lt;&lt; getb(i, cnt) &lt;&lt; endl; if (i == k) cout &lt;&lt; getb(i, cnt) &lt;&lt; endl; &#125;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; k; if ((n - 1) % 2 == 1) cout &lt;&lt; ((k - 1) % n + 1) &lt;&lt; endl; else &#123; // brute(); if (k &gt; n / 2) &#123; int tmp = k - n / 2; tmp - 1; int cnt = tmp / (n / 2) + 1; cout &lt;&lt; (k + cnt - 1) % n + 1 &lt;&lt; endl; &#125; else cout &lt;&lt; (k - 1) % n + 1 &lt;&lt; endl; &#125; &#125; return 0;&#125; 1487C - Minimum Ties Problem nnn 只队伍踢足球比赛，胜者积三分，败者不积分，平局双方积一分； 每两支队伍踢一场比赛，各队最终积分相等，构造平局最少的比赛结果。 Analysis 思维 贪心 图论 偶数支球队，每支踢 n−1n - 1n−1 场，胜负各半； 奇数支球队，平局一场，剩余胜负各半，构造时，贪心策略：能赢就赢。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100 + 7;int T;int n;int cnt1[MAXN], cnt2[MAXN];void odd(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; if (j &lt;= i + n / 2) cout &lt;&lt; 1 &lt;&lt; &quot; &quot;; else cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; &#125; &#125;&#125;void eve(int n)&#123; memset(cnt1, 0, sizeof(cnt1)); memset(cnt2, 0, sizeof(cnt2)); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; if (i % 2 &amp;&amp; j == i + 1) cout &lt;&lt; 0 &lt;&lt; &quot; &quot;; else if (cnt1[i] &lt; n / 2 - 1 &amp;&amp; cnt2[j] &lt; n / 2 - 1) cnt1[i]++, cnt2[j]++, cout &lt;&lt; 1 &lt;&lt; &quot; &quot;; else cnt2[i]++, cnt1[j]++, cout &lt;&lt; -1 &lt;&lt; &quot; &quot;; &#125; &#125;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; if (n % 2) odd(n); else eve(n); cout &lt;&lt; endl; &#125; return 0;&#125; 1487D - Pythagorean Triples Problem 正整数范围内，能构成直角三角形的三个整数且满足 c=a2−bc = a^2 - bc=a2−b 的三元组有多少个。 Analysis 数学 c=a2−bc = a^2 - bc=a2−b 且 c2=a2+b2c^2 = a^2 + b^2c2=a2+b2 可得 (c+b)(c−b−1)=0(c + b)(c - b - 1) = 0(c+b)(c−b−1)=0； 故，c=b+1, a2=2b+1&lt;nc = b + 1 ,\\ a^2 = 2b + 1 &lt; \\sqrt nc=b+1, a2=2b+1&lt;n​，枚举 [1, n][1 ,\\ \\sqrt n][1, n​]。 Code 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;using namespace std;int T, n;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; int ans = 0; for (int i = 2; i * i - 1 &lt;= 2 * n; ++i) &#123; int a, b, c; a = i; if ((i * i - 1) % 2 == 1) continue; b = (i * i - 1) / 2; c = b + 1; if (a &lt;= n &amp;&amp; b &lt;= n &amp;&amp; c &lt;= n &amp;&amp; a * a + b * b == c * c) ++ans; // cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1487E - Cheap Dinner","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"}]},{"title":"Codeforces Round #701 (Rated for Div. 2)","slug":"Codeforces-Round-701-Rated-for-Div-2","date":"2021-02-16T13:53:31.000Z","updated":"2021-02-16T15:05:05.197Z","comments":true,"path":"2021/02/16/Codeforces-Round-701-Rated-for-Div-2/","link":"","permalink":"https://noginonoka.github.io/2021/02/16/Codeforces-Round-701-Rated-for-Div-2/","excerpt":"","text":"Codeforces 1485 1485A - Add and Divide Analysis 贪心 暴力 比较 ⌊abn⌋\\lfloor \\dfrac{a}{b ^ n} \\rfloor⌊bna​⌋ 与 ⌊a(b+i)n−i⌋\\lfloor \\dfrac{a}{(b + i) ^{n - i}} \\rfloor⌊(b+i)n−ia​⌋，每一次判断 iii 复杂度为 log⁡a\\log aloga，总复杂度为 O(log⁡2a)O(\\log^2 a)O(log2a)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;int T;int a, b;int solve(int a, int b)&#123; int ans = 0; int tmp = a; int tmpb = b; while (tmp) &#123; if (tmpb == 1) ++ans, ++tmpb; else ++ans, tmp /= tmpb; &#125; for (int i = 1; i &lt; ans; ++i) &#123; int cnt = i; tmp = a; tmpb = b + i; while (tmp) &#123; ++cnt; tmp /= tmpb; &#125; if (cnt &lt; ans) ans = cnt; &#125; return ans;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; solve(a, b) &lt;&lt; endl; &#125; return 0;&#125; 1485B - Replace and Keep Sorted Problem 给定长度为 nnn 的严格递增序列 aaa，最大值不超过 kkk; qqq 次询问，区间 [l, r][l, \\ r][l, r] 中，满足： 有且仅有一个数与原序列不同； 仍保持序列单调递增； 询问满足条件的序列个数。 Analysis 贪心 前缀和 对于第 iii 位上能够修改的数只与 ai−1a_{i - 1}ai−1​ 与 ai+1a_{i + 1}ai+1​ 有关； 预处理求前缀和，对于询问 [l, r][l,\\ r][l, r] 处理区间内部 [l+1, r−1][l + 1,\\ r - 1][l+1, r−1] 的和 sumr−1−sumlsum_{r - 1} - sum{l}sumr−1​−suml，再分别判断段点情况； 另外，考虑区间特判情况。 Code 没判 l=n, r=1l = n ,\\ r = 1l=n, r=1 的情况 WA 在 System Test。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl &quot;\\n&quot;const int MAXN = 1e5 + 7;int n, q, k;int a[MAXN];int cnt[MAXN];int sum[MAXN];int l, r;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; q &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; cnt[1] = a[2] - 1; cnt[n] = k - a[n - 1]; for (int i = 2; i &lt; n; ++i) cnt[i] = a[i + 1] - a[i - 1] - 1; sum[0] = 0; for (int i = 1; i &lt;= n; ++i) sum[i] = sum[i - 1] + cnt[i]; for (int i = 1; i &lt;= q; ++i) &#123; cin &gt;&gt; l &gt;&gt; r; if (l == n || r == 1) &#123; cout &lt;&lt; k - 1 &lt;&lt; endl; continue; &#125; int ans = 0; ans += a[l + 1] - 1; ans += k - a[r - 1]; ans += sum[r - 1] - sum[l]; ans -= (r - l + 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 1485C - Floor and Mod Problem 给定 x yx \\ yx y； 询问 1≤a≤x, 1≤b≤y1 \\le a \\le x,\\ 1 \\le b \\le y1≤a≤x, 1≤b≤y，满足 ⌊ab⌋=a%b\\lfloor \\dfrac{a}{b} \\rfloor = a \\% b⌊ba​⌋=a%b 的 &lt;a, b&gt;&lt;a ,\\ b&gt;&lt;a, b&gt; 有多少对。 Analysis Personel Solution 思维 二分查找 显然，a=tb+t=t(b+1)≤x, t&lt;b&lt;ya = tb + t = t(b + 1) \\le x,\\ t &lt; b &lt; ya=tb+t=t(b+1)≤x, t&lt;b&lt;y； 对于每一个 bbb 的贡献为 ans=min⁡(ab+1,b−1)ans = \\min(\\dfrac{a}{b + 1}, b - 1)ans=min(b+1a​,b−1)； 分别讨论 ansansans 可能的情况： ans=b−1ans = b - 1ans=b−1 时，二分查找满足条件的点； ans=div=ab+1ans = div = \\dfrac{a}{b + 1}ans=div=b+1a​ 时，divdivdiv 递减，满足二分的性质。 Official Solution We can notice that, if ⌊ab⌋=a mod b=k\\lfloor \\frac{a}{b} \\rfloor = a~\\mathrm{mod}~b = k⌊ba​⌋=a mod b=k, then aaa can be written as kb+kkb+kkb+k (b&gt;kb &gt; kb&gt;k). Since b&gt;kb &gt; kb&gt;k, we have that k2&lt;kb+k=a≤xk^2 &lt; kb+k = a \\leq xk2&lt;kb+k=a≤x. Hence k≤xk \\leq \\sqrt xk≤x​. Now let’s count special pairs for any fixed kkk (1≤k≤x1 \\leq k \\leq \\sqrt x1≤k≤x​). For each kkk, you have to count the number of bbb such that b&gt;kb &gt; kb&gt;k, 1≤b≤y1 \\leq b \\leq y1≤b≤y, 1≤kb+k≤x1 \\leq kb+k \\leq x1≤kb+k≤x. The second condition is equivalent to 1≤b≤x/k−11 \\leq b \\leq x/k-11≤b≤x/k−1. Therefore, for any fixed k&gt;0k &gt; 0k&gt;0, the number of special pairs (a≤xa\\leq xa≤x; b≤yb \\leq yb≤y) is max(0,min(y,x/k−1)−k)max(0, min(y,x/k-1) - k)max(0,min(y,x/k−1)−k). The result is the sum of the number of special pairs for each kkk. Complexity: O(x)O(\\sqrt x)O(x​). Code Personel 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl &quot;\\n&quot;int T;int x, y;int bruteForce(int x, int y)&#123; int ans = 0; for (int i = 2; i &lt;= min(x, y); ++i) &#123; ans += min(x / (i + 1), i - 1); &#125; return ans;&#125;bool check(int mid)&#123; if (x / (mid + 1) &gt;= mid - 1) return true; return false;&#125;bool check2(int div, int mid)&#123; if (x / (mid + 1) &gt;= div) return true; return false;&#125;int solve(int x, int y)&#123; int ans = 0; int l = 2, r = min(x, y); while (l &lt; r) &#123; int mid = (l + r) / 2; if (check(mid)) l = mid + 1; else r = mid; &#125; if (r == min(x, y) &amp;&amp; check(r)) &#123; ans += (1 + (r - 1)) * (r - 1) / 2; return ans; &#125; --r; ans += (1 + (r - 1)) * (r - 1) / 2; for (int div = x / (l + 1); div &gt;= 1; --div) &#123; int pos = l; r = min(x, y); while (l &lt; r) &#123; int mid = (l + r) / 2; if (check2(div, mid)) l = mid + 1; else r = mid; &#125; ans += (r - pos) * div; &#125; ans += x / (min(x, y) + 1); return ans;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; x &gt;&gt; y; // cout &lt;&lt; brute_force(x, y) &lt;&lt; &quot; &quot;; cout &lt;&lt; solve(x, y) &lt;&lt; endl; &#125; return 0;&#125; Official 123456789101112131415161718192021#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;void solve()&#123; ll x, y; cin &gt;&gt; x &gt;&gt; y; ll ans = 0; for(ll i = 1; i*i &lt; x; i++)ans+=max(min(y,x/i-1)-i,0LL); cout &lt;&lt; ans &lt;&lt; endl; return;&#125;int main()&#123; int T = 1; cin &gt;&gt; T; while(T--)&#123; solve(); &#125; return 0;&#125; 1485D - Multiples and Power Differences Problem 给定 n×mn \\times mn×m 的矩阵 a (1≤ai,j≤16)a \\ (1 \\le a_{i,j} \\le 16)a (1≤ai,j​≤16)； 构造一个矩阵 bbb 满足： bi,j=t⋅ai,jb_{i,j} = t \\cdot a_{i,j}bi,j​=t⋅ai,j​； 相邻的元素之差为 k4 (k≥1)k^4 \\ (k \\ge 1)k4 (k≥1)，kkk 可以不同。 Analysis 思维 构造 由于 1≤ai,j≤161 \\le a_{i,j} \\le 161≤ai,j​≤16，构造条件一 bi,j=lcm(1,2,…,16)=720720b_{i, j} = lcm(1, 2, \\dots, 16) = 720720bi,j​=lcm(1,2,…,16)=720720； 构造条件二，在相邻元素原先的基础上 720720+ai,j4720720 + a_{i, j}^4720720+ai,j4​。 Code 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 5e2 + 7;int n , m;int a[MAXN][MAXN];int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); // int ans = 1; // for (int i = 1; i &lt;= 16; ++i) // &#123; // int g = __gcd(i, a); // ans *= i; ans /= g; // &#125; // cout &lt;&lt; ans &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) cin &gt;&gt; a[i][j]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if ((i + j) % 2) cout &lt;&lt; 720720 &lt;&lt; &quot; &quot;; else cout &lt;&lt; (a[i][j] * a[i][j] * a[i][j] * a[i][j] + 720720) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1485E - Move and Swap Problem 给定 nnn 个节点的树，给定每个节点的权值 valvalval； 存在红色与蓝色的两个点位于根节点，服从以下规则： 红节点转移至原节点的任一子节点； 蓝节点转移至与红节点同一层的任一点； （可选）红蓝节点可以选择是否交换位置； 每一次操作可以得到 ∣valr−valb∣|val_r - val_b|∣valr​−valb​∣ 的点数； 询问最多得到多少点数。 Analysis 树型DP 状态转移方程： dpu=max⁡(dpu, dpv+∣valv−valm∣)dpu=max⁡(dpu, dpm+∣valv−valm∣)\\begin{array}{c} dp_u = \\max(dp_u,\\ dp_v + |val_v - val_m|)\\\\ dp_u = \\max(dp_u,\\ dp_m + |val_v - val_m|) \\end{array} dpu​=max(dpu​, dpv​+∣valv​−valm​∣)dpu​=max(dpu​, dpm​+∣valv​−valm​∣)​ 共两种情况： 红节点由其子节点转移而来； 红节点由其他节点与子节点交换而来； DFS 求节点深度并记录父结点， 处理情况一，记录同层节点最值 valmval_mvalm​，从深度最高节点开始更新其父节点最大点数； 处理情况二，从同层节点中分别维护 dpi±validp_i \\pm val_idpi​±vali​ 最大值，非子结点选择只有两种情况 vali−valv&gt;0val_i - val_v &gt; 0vali​−valv​&gt;0 或 valv−vali&gt;0val_v - val_i &gt; 0valv​−vali​&gt;0，更新 dpudp_udpu​。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXN = 2e5 + 7;const int INF = 0x3f3f3f3f3f3f3f3f;int T;int n;int val[MAXN];int dp[MAXN];int dep[MAXN];int maxdep;int fa[MAXN];vector&lt;int&gt; graph[MAXN];struct Edge&#123; int to; int nxt;&#125;edge[MAXN];int cntEdge;int head[MAXN];void init(int n)&#123; dep[0] = -1; maxdep = 0; for (int i = 0; i &lt;= n; ++i) &#123; graph[i].clear(); dp[i] = 0; head[i] = -1; &#125; cntEdge = -1;&#125;void addEdge(int u, int v)&#123; ++cntEdge; edge[cntEdge].to = v; edge[cntEdge].nxt = head[u]; head[u] = cntEdge;&#125;void dfsPre(int now, int fr)&#123; fa[now] = fr; dep[now] = dep[fr] + 1; maxdep = max(maxdep, dep[now]); graph[dep[now]].push_back(now); for (int i = head[now]; ~i; i = edge[i].nxt) &#123; int to = edge[i].to; if (to == fr) continue; dfsPre(to, now); &#125;&#125;void solve(int maxdep)&#123; for (int i = maxdep; i; --i) &#123; int vmax = 0, vmin = INF; for (auto j : graph[i]) vmax = max(vmax, val[j]), vmin = min(vmin, val[j]); for (auto j : graph[i]) &#123; int f = fa[j]; dp[f] = max(dp[f], dp[j] + max(abs(val[j] - vmax), abs(val[j] - vmin))); &#125; int v1 = -INF, v2 = -INF; for (auto j : graph[i]) v1 = max(v1, dp[j] - val[j]), v2 = max(v2, dp[j] + val[j]); for (auto j : graph[i]) &#123; int f = fa[j]; dp[f] = max(dp[f], v1 + val[j]); dp[f] = max(dp[f], v2 - val[j]); &#125; &#125;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; init(n); for (int i = 2; i &lt;= n; ++i) &#123; int u; cin &gt;&gt; u; addEdge(u, i); &#125; for (int i = 2; i &lt;= n; ++i) cin &gt;&gt; val[i]; dfsPre(1, 0); solve(maxdep); cout &lt;&lt; dp[1] &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://noginonoka.github.io/tags/Dynamic-Programming/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"}]},{"title":"Algorithm: Network Flow (Maximum Flow)","slug":"Algorithm-Network-Flow-Maximum-Flow","date":"2021-02-14T18:27:16.000Z","updated":"2021-02-14T18:32:13.201Z","comments":true,"path":"2021/02/15/Algorithm-Network-Flow-Maximum-Flow/","link":"","permalink":"https://noginonoka.github.io/2021/02/15/Algorithm-Network-Flow-Maximum-Flow/","excerpt":"","text":"相关概念 网络 Network 流 Flow 源点 s (source) 汇点 t (sink) 增广路 Augmenting Path 割与割集 Cut &amp; Cut Set 增广路定理 Augmenting Path Theorem：网络达到最大流当且仅当残留网络中没有增广路。 解决问题 最小割 最大流最小割定理 Maximum Flow Minimum Cut Theorem：最大流 = 最小割 最大权闭合子图 定义：有向图中，任一点都有权值，包含每个点的后继且权值和最大的子图。 解法： 转化为最小割（最大流）问题； 建图： 正权点建边 s→is \\rightarrow is→i； 负权点建边 j→tj \\rightarrow tj→t； 边的含义： s→is \\rightarrow is→i 表示选择 iii； j→tj \\rightarrow tj→t 表示不选择 jjj； 闭合子图：当 sss 与 ttt 不连通时，才能得到闭合子图。 假设 sss 与 ttt 连通，则存在路径 s→i→j→ts \\rightarrow i \\rightarrow j \\rightarrow ts→i→j→t 使得子图中选择 iii 未选择其后继 jjj。 假设 sss 与 ttt 不连通，若存在路径 s→is \\rightarrow is→i，对于所有的负权后继节点 jjj 不存在 j→tj \\rightarrow tj→t 此时选择 jjj，对于所有正权后继节 jjj，由于存在 s→is \\rightarrow is→i，最小割不会把 s→js \\rightarrow js→j 割掉 此时选择 jjj。 最大权闭合子图权值计算： 最大权闭合子图权值 === 正权节点权值和 −-− 未选正权节点权值和 −-− 已选负权节点权值和（绝对值）； 最小割 === 最大流 === 未选正权节点权值和 +++ 已选负权节点权值和（绝对值）； 最大权闭合子图权值 === 正权节点权值和 −-− 最小割。 算法思路 Edomonds-Karp 算法 BFS 找增广路 时间复杂度：O(VE2)O(VE^2)O(VE2) Template 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct EdmondsKarp&#123; // Edmonds Karp Algorithm // Find Max Flow in nonnegative Graph // Time Complexity: O(VE^2) int s, t; // Start &amp;&amp; End int n; // Num of Nodes int capacity[MAXN][MAXN]; // Adjacency Matrix int flow[MAXN][MAXN]; int res[MAXN]; // flow in augmenting path int pre[MAXN]; // predecessor void init() &#123; memset(capacity, 0, sizeof(capacity)); memset(flow, 0, sizeof(flow)); &#125; void addEdge(int u, int v, int w) &#123; capacity[u][v] += w; // may have Multiple Edge &#125; bool bfs() &#123; queue&lt;int&gt; q; memset(res, 0, sizeof(res)); res[s] = INF; pre[s] = -1; q.push(s); while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = 1; i &lt;= num; ++i) &#123; if (!res[i] &amp;&amp; flow[now][i] &lt; capacity[now][i]) &#123; q.push(i); res[i] = min(res[now], capacity[now][i] - flow[now][i]); pre[i] = now; if (i == t) return true; // find augmenting path &#125; &#125; &#125; return false; &#125; int edmondskarp() &#123; // add Reverse Edge in Adjacency List int ans = 0; while (bfs()) &#123; for (int i = t; i != -1; i = pre[i]) &#123; flow[pre[i]][i] += res[t]; flow[i][pre[i]] -= res[t]; &#125; ans += res[t]; &#125; return ans; &#125;&#125;ek; Dicnic 算法 时间复杂度：O(V2E)O(V^2E)O(V2E) 多路增广：在一次 DFS 中找出多条增广路。 当前弧优化：如果一条边已经被增广过，那么它就没有可能被增广第二次。我们下一次进行增广的时候，就可以不必再走那些已经被增广过的边。每次增广时，记录链式前向星中当前节点访问到的位置。 Template 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293struct Dicnic&#123; // Dicnic Algorithm // Find Max Flow in nonnegative Graph // Time Complexity: O(V^2E) // Edge add twice for Reverse Edge struct Edge &#123; int to; int val; int nxt; &#125;edge[MAXE * 2]; int cntEdge; int head[MAXN]; void init() &#123; cntEdge = -1; // edge 0 ^ 1 = reverse edge 1 memset(head, -1, sizeof(head)); &#125; void addEdge(int u, int v, int w) &#123; ++cntEdge; edge[cntEdge].to = v; edge[cntEdge].val = w; edge[cntEdge].nxt = head[u]; head[u] = cntEdge; &#125; int n; int s, t; int dep[MAXN]; // depth in BFS int arc[MAXN]; // arc optimization bool bfs() &#123; memset(dep, -1, sizeof(dep)); queue&lt;int&gt; q; dep[s] = 0; arc[s] = head[s]; q.push(s); while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; ~i; i = edge[i].nxt) &#123; int to = edge[i].to; if (dep[to] == -1 &amp;&amp; edge[i].val &gt; 0) &#123; dep[to] = dep[now] + 1; arc[to] = head[to]; q.push(to); if (to == t) return true; &#125; &#125; &#125; return false; &#125; int dfs(int now, int flow) &#123; if (now == t) return flow; int res = 0; for (int i = arc[now]; (~i) &amp;&amp; flow; i = edge[i].nxt) &#123; arc[now] = i; int to = edge[i].to; if (dep[to] == dep[now] + 1 &amp;&amp; edge[i].val &gt; 0) &#123; int nxtFlow = dfs(to, min(flow, edge[i].val)); if (nxtFlow == 0) dep[to] = -1; edge[i].val -= nxtFlow; edge[i ^ 1].val += nxtFlow; flow -= nxtFlow; res += nxtFlow; &#125; &#125; return res; &#125; int dicnic() &#123; int ans = 0; while (bfs()) ans += dfs(s, INF); return ans; &#125;&#125;dic; ISAP (Improved Shortest Augment Path) 多路增广 当前弧优化 GAP 优化 通过一次 BFS 给图中所有节点分层，并统计深度相同的节点个数； 当某一层节点个数为 0 时增广结束。 Template 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104struct ISAP&#123; // ISAP Algorithm // BFS once // Edge add twice for Reverse Edge struct Edge &#123; int to; int val; int nxt; &#125;edge[MAXE]; int cntEdge; int head[MAXN]; void init() &#123; cntEdge = -1; memset(head, -1, sizeof(head)); &#125; void addEdge(int u, int v, int w) &#123; ++cntEdge; edge[cntEdge].to = v; edge[cntEdge].val = w; edge[cntEdge].nxt = head[u]; head[u] = cntEdge; &#125; int n; // num of nodes int s, t; // source &amp; sink int dep[MAXN]; // depth in BFS dep[t] = 1; int arc[MAXN]; // arc optimization int gap[MAXN]; // gap (num of dep) optimization void bfs() &#123; memset(dep, -1, sizeof(dep)); memset(gap, 0, sizeof(gap)); queue&lt;int&gt; q; q.push(t); dep[t] = 0; arc[t] = head[t]; ++gap[0]; while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; ~i; i = edge[i].nxt) &#123; int to = edge[i].to; if (dep[to] == -1) &#123; dep[to] = dep[now] + 1; arc[to] = head[to]; ++gap[dep[to]]; q.push(to); &#125; &#125; &#125; &#125; int dfs(int now, int flow) &#123; if (now == t) return flow; int res = 0; for (int i = arc[now]; ~i; i = edge[i].nxt) &#123; arc[now] = i; int to = edge[i].to; if (dep[to] + 1 == dep[now] &amp;&amp; edge[i].val &gt; 0) &#123; int nxtFlow = dfs(to, min(flow, edge[i].val)); if (nxtFlow) &#123; edge[i].val -= nxtFlow; edge[i ^ 1].val += nxtFlow; flow -= nxtFlow; res += nxtFlow; &#125; if (flow == 0) return res; &#125; &#125; if (--gap[dep[now]] == 0) dep[s] = n; ++dep[now]; ++gap[dep[now]]; return res; &#125; int isap() &#123; int ans = 0; bfs(); while (dep[s] &lt; n) &#123; memcpy(arc, head, sizeof(head)); ans += dfs(s, INF); &#125; return ans; &#125;&#125;isap; 例题 Luogu P3376 链接：Luogu P3376 模板题 (Edmonds Karp 161ms / Dicnic 42ms / ISAP 32ms) Codeforces 1473F - Strange Set 链接：CF1473F - Strange Set Pronlem 给定长度为 nnn 的数组 aaa 与其权值 bbb; 定义一个 Strange Set，若选择 iii ，则需要选择 ∀j∈[1, i−1], ai%aj=0\\forall j \\in [1,\\ i - 1] ,\\ a_i \\% a_j = 0∀j∈[1, i−1], ai​%aj​=0。 Analysis 网络流 最大权闭合子图 使用最大流 Dicnic 算法解题，复杂度 O(V2E)O(V^2E)O(V2E)； 建图时注意对于数值相同的结点，只连一条边，减少边数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 3e3 + 7;const int MAXE = 1e5 + 7;const int INF = 0x3f3f3f3f;struct Dicnic&#123; // Dicnic Algorithm // Find Max Flow in nonnegative Graph // Time Complexity: O(V^2E) // Edge add twice for Reverse Edge struct Edge &#123; int to; int val; int nxt; &#125;edge[MAXE * 2]; int cntEdge; int head[MAXN]; void init() &#123; cntEdge = -1; // edge 0 ^ 1 = reverse edge 1 memset(head, -1, sizeof(head)); &#125; void addEdge(int u, int v, int w) &#123; ++cntEdge; edge[cntEdge].to = v; edge[cntEdge].val = w; edge[cntEdge].nxt = head[u]; head[u] = cntEdge; &#125; int dep[MAXN]; // depth in BFS int arc[MAXN]; // arc optimization bool bfs(int s, int t) &#123; memset(dep, 0, sizeof(dep)); queue&lt;int&gt; q; dep[s] = 1; arc[s] = head[s]; q.push(s); while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = head[now]; ~i; i = edge[i].nxt) &#123; int to = edge[i].to; if (dep[to] == 0 &amp;&amp; edge[i].val &gt; 0) &#123; dep[to] = dep[now] + 1; arc[to] = head[to]; q.push(to); if (to == t) return true; &#125; &#125; &#125; return false; &#125; int dfs(int now, int flow, int t) &#123; if (now == t) return flow; int res = 0; for (int i = arc[now]; (~i) &amp;&amp; flow; i = edge[i].nxt) &#123; arc[now] = i; int to = edge[i].to; if (edge[i].val &amp;&amp; dep[to] == dep[now] + 1) &#123; int nxtFlow = dfs(to, min(flow, edge[i].val), t); if (nxtFlow == 0) dep[to] = 0; edge[i].val -= nxtFlow; edge[i ^ 1].val += nxtFlow; flow -= nxtFlow; res += nxtFlow; &#125; &#125; return res; &#125; int dicnic(int s, int t) &#123; int ans = 0; while (bfs(s, t)) ans += dfs(s, INF, t); return ans; &#125;&#125;dic;int n;int a[MAXN];bool vis[100 + 7];int ans;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; dic.init(); ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; memset(vis, false, sizeof(vis)); for (int j = i - 1; j; --j) &#123; if (a[i] % a[j] == 0 &amp;&amp; vis[a[j]] == false) &#123; dic.addEdge(i, j, INF); dic.addEdge(j, i, 0); vis[a[j]] = true; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int val; cin &gt;&gt; val; if (val &gt; 0) &#123; dic.addEdge(0, i, val); dic.addEdge(i, 0, 0); ans += val; &#125; else &#123; dic.addEdge(i, n + 1, -val); dic.addEdge(n + 1, i, 0); &#125; &#125; ans -= dic.dicnic(0, n + 1); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://noginonoka.github.io/categories/Algorithm/"}],"tags":[{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://noginonoka.github.io/tags/Graph-Theory/"},{"name":"Network Flow","slug":"Network-Flow","permalink":"https://noginonoka.github.io/tags/Network-Flow/"},{"name":"Template","slug":"Template","permalink":"https://noginonoka.github.io/tags/Template/"}]},{"title":"Algorithm: Digit DP (DFS Memory Search)","slug":"Algorithm-Digit-DP","date":"2021-02-12T09:51:36.000Z","updated":"2021-02-13T11:41:42.909Z","comments":true,"path":"2021/02/12/Algorithm-Digit-DP/","link":"","permalink":"https://noginonoka.github.io/2021/02/12/Algorithm-Digit-DP/","excerpt":"","text":"解决问题 数位 DP 通常用于解决区间 [L, R][L,\\ R][L, R] 内符合条件的数的个数。 算法思想 数位 DP 的实现主要有两种： 递推 构建转移方程 记忆化搜索 其中，记忆化搜索更易实现且能解决更多问题，本文主要介绍记忆化搜索的实现方式。 算法实现 基于 DFS 的记忆化搜索，主要维护当前位数、条件、数位上限等参数。 通过待求区间上限，计算 limlimlim 得到数位上限与 pospospos 最大值； 递归更新当前条件值 / 数位值等，判断是否处于上限； 更新 DP 数组。 123456789101112131415161718192021222324int lim[];int pos_max;function pre(int x)&#123; pos_max &#x3D; 0; while x: lim[pos_max++] &#x3D; x % radix; x &#x2F;&#x3D; radix;&#125;function dfs(int pos, bool condition, bool limit)&#123; if pos &#x3D;&#x3D; 0: return 1; if dp[pos][condition][limit]: return dp[pos][condition][limit]; int top &#x3D; limit ? lim[pos] : digit_max; int ans &#x3D; 0; for i &#x3D; 0 to top: if check(i): ans +&#x3D; dfs(pos - 1, new_condition, new_limit); return dp[pos][condition][limit] &#x3D; ans;&#125; 例题 Luogu P2657 链接：P2657 Problem 在区间 [a, b][a,\\ b][a, b] 间不含前导零且相邻两个数字之差至少为 222 的正整数个数。 Analysis 前缀和思想，处理区间 [1, b]−[1, a−1][1,\\ b] - [1,\\ a - 1][1, b]−[1, a−1]。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;int a, b;int dp[15][15][2][2];int len;int lim[15];void pre(int x)&#123; memset(dp, -1, sizeof(dp)); len = 0; while (x) &#123; lim[len++] = x % 10; x /= 10; &#125;&#125;int dfs(int now, int pre, bool zero, bool limit)&#123; if (now == -1) &#123; if (zero) return 0; else return 1; &#125; if (~dp[now][pre][zero][limit]) return dp[now][pre][zero][limit]; int top = limit ? lim[now] : 9; int ans = 0; for (int i = 0; i &lt;= top; ++i) &#123; if (zero || abs(i - pre) &gt;= 2) ans += dfs(now - 1, i, zero &amp; (i == 0), limit &amp; (i == lim[now])); &#125; return dp[now][pre][zero][limit] = ans;&#125;void solve()&#123; cin &gt;&gt; a &gt;&gt; b; pre(b); int ans; ans = dfs(len - 1, 0, true, true); pre(a - 1); ans -= dfs(len - 1, 0, true, true); cout &lt;&lt; ans &lt;&lt; endl;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); solve(); return 0;&#125; 2020 ICPC Jinan L - Bit Sequence 链接：Bit Sequence Problem 给定长度为 m (1≤m≤100)m \\ (1 \\le m \\le 100)m (1≤m≤100) 的二进制序列 aaa，aia_iai​ 表示 x+ix + ix+i 中 111 个数的奇偶性； 询问在区间 [0, l] (0≤l≤1018)[0,\\ l] \\ (0 \\le l \\le 10^{18})[0, l] (0≤l≤1018) 内，满足条件的 xxx 的个数。 Analysis 注意到 m≤100m \\le 100m≤100，故产生变化的位数在最后 8 bit8 \\ bit8 bit； 同时，后 8 bit8 \\ bit8 bit 可能产生进位对前连续的 111 个数的奇偶性可能产生影响； 故，影响 aia_iai​ 的所有可能条件为： 后 8 bit8 \\ bit8 bit 的中 111 个数的奇偶性； 除后 8 bit8 \\ bit8 bit 剩余 111 个数的奇偶性； 产生进位，后 8 bit8 \\ bit8 bit 前连续的 111 个数的奇偶性。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXN = 1e5 + 7;int T;int m, l;int a[MAXN];int lim[70];int dp[70][2][2][2];int cnt[130];void pre()&#123; cnt[0] = 0; for (int i = 1; i &lt; 128; i++) cnt[i] = (cnt[i &gt;&gt; 1] + (i &amp; 1)) % 2;&#125;int cal(bool sum, bool one, bool limit)&#123; int top = (limit ? l % 128 + 1 : 128); int ans = 0; for (int i = 0; i &lt; top; i++) &#123; bool ok = true; for (int j = 0; j &lt; m &amp;&amp; ok; j++) &#123; if (i + j &lt; 128) ok = ((cnt[i + j] ^ sum) == a[j]); else ok = ((cnt[(i + j) % 128] ^ (1 - one) ^ sum) == a[j]); &#125; ans += ok; &#125; return ans;&#125;int dfs(int step, bool sum, bool one, bool limit) // 数位, 1 的总数, 连续 1 的个数, 上限&#123; if (~dp[step][sum][one][limit]) return dp[step][sum][one][limit]; if (step &lt;= 6) return dp[step][sum][one][limit] = cal(sum, one, limit); int top = (limit ? lim[step] : 1); int ans = 0; for (int i = 0; i &lt;= top; i++) ans += dfs(step - 1, sum ^ i, i ? one ^ 1 : 0, limit &amp; (i == top)); return dp[step][sum][one][limit] = ans;&#125;int solve(int x)&#123; memset(dp, -1, sizeof(dp)); int len = 0; while (x) &#123; lim[len++] = x &amp; 1; x &gt;&gt;= 1; &#125; return dfs(len - 1, 0, 0, true);&#125;int32_t main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; pre(); while (T--) &#123; cin &gt;&gt; m; cin &gt;&gt; l; for (int i = 0; i &lt; m; i++) cin &gt;&gt; a[i]; cout &lt;&lt; solve(l) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://noginonoka.github.io/categories/Algorithm/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://noginonoka.github.io/tags/ICPC/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://noginonoka.github.io/tags/Dynamic-Programming/"},{"name":"Memory Search","slug":"Memory-Search","permalink":"https://noginonoka.github.io/tags/Memory-Search/"}]},{"title":"Codeforces Round #700 (Rated for Div. 2 / Div. 1)","slug":"Codeforces-Round-700-Rated-for-Div-2-Div-1","date":"2021-02-10T10:32:13.000Z","updated":"2021-02-16T13:54:43.650Z","comments":true,"path":"2021/02/10/Codeforces-Round-700-Rated-for-Div-2-Div-1/","link":"","permalink":"https://noginonoka.github.io/2021/02/10/Codeforces-Round-700-Rated-for-Div-2-Div-1/","excerpt":"","text":"Codeforces 1480 / 1479 1480A - Yet Another String Game 贪心 1480B - The Great Hero 贪心 1480C - Searching Local Minimum Problem 交互题 生成长度为 [1, n] (1≤n≤105)[1,\\ n] \\ (1 \\le n \\le 10^{5})[1, n] (1≤n≤105) 的 序列 aaa； 至多 100100100 次询问，询问第 iii 处 aia_iai​，输出? i? \\ i? i； 寻找 aia_iai​ 使得 ai&lt;ai−1, ai&lt;ai+1a_i &lt; a_{i - 1},\\ a_i &lt; a_{i + 1}ai​&lt;ai−1​, ai​&lt;ai+1​，输出 ! i! \\ i! i。 Analysis 思维 二分查找 询问 iii 若 iii 不满足，且 ai&lt;ai+1a_i &lt; a_{i + 1}ai​&lt;ai+1​，则在 iii 的左侧必然存在满足的值。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 7;const int INF = 0x3f3f3f3f;int n;int a[MAXN];void ask(int x)&#123; if (a[x] != 0) return; cout &lt;&lt; &quot;? &quot; &lt;&lt; x &lt;&lt; endl; cin &gt;&gt; a[x];&#125;bool check(int x)&#123; if (a[x - 1] &gt; a[x] &amp;&amp; a[x + 1] &gt; a[x]) return true; return false;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); memset(a, 0, sizeof(a)); cin &gt;&gt; n; a[0] = a[n + 1] = INF; ask(1); if (n == 1) &#123; cout &lt;&lt; &quot;! &quot; &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; ask(2); if (check(1)) &#123; cout &lt;&lt; &quot;! &quot; &lt;&lt; 1 &lt;&lt; endl; return 0; &#125; ask(n); ask(n - 1); if (check(n)) &#123; cout &lt;&lt; &quot;! &quot; &lt;&lt; n &lt;&lt; endl; return 0; &#125; int l = 1, r = n; for (int i = 1; i &lt;= 32; ++i) &#123; int mid = (l + r) / 2; ask(mid); ask(mid + 1); ask(mid - 1); if (check(mid)) &#123; cout &lt;&lt; &quot;! &quot; &lt;&lt; mid &lt;&lt; endl; break; &#125; if (mid &gt; a[mid]) r = mid - 1; else l = mid + 1; &#125; return 0;&#125; 1480D1 - Painting the Array I Problem 给定数组 aaa 将其拆分为两个数组 x yx \\ yx y； 定义操作数组压缩，将连续的相同数压缩； seg(a)seg(a)seg(a) 表示计算压缩后数组长度; 询问 seg(x)+seg(y)seg(x) + seg(y)seg(x)+seg(y) 的最大值。 Analysis 贪心 对于原数组 aaa 中连续且相同的区间，至多有效贡献为 222； 预处理，将原数组进行初步压缩（保证相同且连续不超过 222）得到 a′a&#x27;a′； 对于不同的数，贡献必然为 111； 对于连续且相同的数，贡献为 1 21 \\ 21 2 的情况： 维护两序列栈顶 topx topytop_x \\ top_ytopx​ topy​ 的情况，比较 aia_iai​，若： ai≠topx, ai≠topya_i \\ne top_x,\\ a_i \\ne top_yai​​=topx​, ai​​=topy​ ai=topx or ai=topxa_i = top_x \\ or \\ a_i = top_xai​=topx​ or ai​=topx​ 此时均有最优解； 对于 ai=topx, ai=topya_i = top_x,\\ a_i = top_yai​=topx​, ai​=topy​，讨论 aia_iai​ 的位置， ai+1=topxa_{i + 1} = top_xai+1​=topx​ 放在 xxx; ai+1=topya_{i + 1} = top_yai+1​=topy​ 放在 yyy; 若均不等，则任意。 当且仅当 i i j i ii \\ i \\ j \\ i \\ ii i j i i 中 第二组 iii 的贡献为 111。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 7;int n;int a[MAXN];int cnt0, cnt1;int now0, now1;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; memset(pos, 0, sizeof(pos)); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; cnt0 = 0; cnt1 = 0; now0 = -1, now1 = -1; bool flg = false; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] == now0 &amp;&amp; a[i] == now1) continue; else if (a[i] == now1) &#123; now0 = a[i]; ++cnt0; &#125; else if (a[i] == now0) &#123; now1 = a[i]; cnt1++; &#125; else &#123; if (a[i + 1] == now1 &amp;&amp; a[i + 1] != now0) &#123; now1 = a[i]; ++cnt1; &#125; else if (a[i + 1] == now0 &amp;&amp; a[i + 1] != now1) &#123; now0 = a[i]; ++cnt0; &#125; else &#123; now0 = a[i]; ++cnt1; &#125; &#125; &#125; cout &lt;&lt; (cnt0 + cnt1) &lt;&lt; endl; return 0;&#125; 1480D2 - Painting the Array II Problem 与 1480D11480D11480D1 不同，询问 seg(x)+seg(y)seg(x) + seg(y)seg(x)+seg(y) 的最小值。 Analysis 贪心 预处理，将连续且相同的数合并，得到完全不同的数组； 维护 ai=xa_i = xai​=x 时，下一个 xxx 出现的位置，nxtinxt_inxti​； 维护两数组栈顶元素，贪心合并； 对于 ai≠topx, ai≠topya_i \\ne top_x,\\ a_i \\ne top_yai​​=topx​, ai​​=topy​： 判断 ai+1a_{i + 1}ai+1​； 判断 nxtxnxt_{x}nxtx​ 与 nxtynxt_{y}nxty​ 较小者更有可能被合并。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 7;int n;int a[MAXN];vector&lt;int&gt; pos[MAXN];int nxt[MAXN];int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; int cur = 0; a[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int tmp; cin &gt;&gt; tmp; if (tmp != a[cur]) &#123; a[++cur] = tmp; pos[a[cur]].push_back(cur); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; (int)pos[i].size() - 1; ++j) nxt[pos[i][j]] = pos[i][j + 1]; if (pos[i].size()) nxt[pos[i][pos[i].size() - 1]] = cur + 1; &#125; int cnt0 = 0, cnt1 = 0; int pos0 = 0, pos1 = 0; nxt[0] = cur + 1; for (int i = 1; i &lt;= cur; ++i) &#123; if (a[i] == a[pos0]) &#123; pos0 = i; &#125; else if (a[i] == a[pos1]) &#123; pos1 = i; &#125; else &#123; if (a[i + 1] == a[pos0] &amp;&amp; a[i + 1] != a[pos1]) &#123; ++cnt1; pos1 = i; &#125; else if (a[i + 1] == a[pos1] &amp;&amp; a[i + 1] != a[pos0]) &#123; ++cnt0; pos0 = i; &#125; else &#123; if (nxt[pos0] &lt; nxt[pos1]) &#123; ++cnt1; pos1 = i; &#125; else &#123; ++cnt0; pos0 = i; &#125; &#125; &#125; &#125; cout &lt;&lt; (cnt0 + cnt1) &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"},{"name":"Greedy","slug":"Greedy","permalink":"https://noginonoka.github.io/tags/Greedy/"}]},{"title":"Codeforces Round #699 (Rated for Div. 2)","slug":"Codeforces-Round-699-Rated-for-Div-2","date":"2021-02-08T09:46:23.000Z","updated":"2021-02-16T13:54:52.315Z","comments":true,"path":"2021/02/08/Codeforces-Round-699-Rated-for-Div-2/","link":"","permalink":"https://noginonoka.github.io/2021/02/08/Codeforces-Round-699-Rated-for-Div-2/","excerpt":"","text":"A. Space Navigation Problem 给定操作序列 sss； 包含如下操作： UUU：上移一格 DDD：下移一格 RRR：右移一格 LLL：左移一格 询问是否可以通过删减操作序列，使得位于坐标 (0, 0)(0, \\ 0)(0, 0) 的飞船，通过删减后的操作序列到达 (px, py)(p_x,\\ p_y)(px​, py​)。 Analysis 贪心 分别统计 U L D RU \\ L \\ D \\ RU L D R 的操作个数。 B. New Colony Problem 给定长度为 n (1≤n≤100)n \\ (1 \\le n \\le 100)n (1≤n≤100) 的数组 h (1≤hi≤100)h \\ (1 \\le h_i \\le 100)h (1≤hi​≤100)； 每一次操作： 找到第一个 hi&lt;hi+1h_{i} &lt; h _{i + 1}hi​&lt;hi+1​，将 hi+1h_{i} + 1hi​+1； 若找不到则 i=−1i = -1i=−1; 询问 kkk 次操作后，iii 的值。 Analysis 模拟 暴力 数据范围很小，直接暴力模拟。 C. Fence Painting Problem 给定长度为 nnn 的原序列 aaa； 给定改变后序列 bbb； 给定长度为 mmm 的修改操作序列 ccc，cic_ici​ 仅能操作一次，且必须操作； 判断能否得到修改后的操作 bbb。 Analysis 贪心 模拟 比较 a ba \\ ba b 序列，得到必须修改的序列及下标 b1b1b1； 比较 b1b1b1 是否被包含在 ccc 中，贪心求出 ccc 中被使用的所有序列元素； 判断 cmc_mcm​ 是否被操作，因为 cmc_mcm​ 是最后一个操作，若被操作，可将其余为被操作元素操作在 cmc_mcm​ 的相同位置上；若未被操作，寻找 bbb 中是否有相同元素，若找到，操作 cmc_mcm​，若未找到，则不能得到 bbb。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e5 + 7;int T;int n, m;int a[MAXN];int b[MAXN];int c[MAXN];int cnt;pair&lt;int, int&gt; c1[MAXN];pair&lt;int, int&gt; b1[MAXN];int ans[MAXN];bool check()&#123; int i = 0, j = 0; while (i &lt; m &amp;&amp; j &lt; cnt) &#123; if (c1[i + 1].second == b1[j + 1].second) ans[c1[i + 1].first] = b1[j + 1].first, ++i, ++j; else ++i; &#125; if (j != cnt) return false; if (!(~ans[m])) &#123; bool flg = false; for (int k = 1; k &lt;= n; ++k) &#123; if (b[k] == c[m]) &#123; ans[m] = k; flg = true; break; &#125; &#125; if (!flg) return false; &#125; for (int k = 1; k &lt; m; ++k) &#123; if (!(~ans[k])) &#123; ans[k] = ans[m]; &#125; &#125; return true;&#125;bool cmp(pair&lt;int, int&gt; &amp;a, pair&lt;int, int&gt; &amp;b)&#123; return a.second &lt; b.second;&#125;void solve()&#123; cin &gt;&gt; n &gt;&gt; m; memset(ans, -1, sizeof(ans)); for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; b[i]; if (b[i] != a[i]) b1[++cnt] = &#123;i, b[i]&#125;; &#125; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; c[i]; c1[i] = &#123;i, c[i]&#125;; &#125; sort(c1, c1 + m + 1, cmp); sort(b1, b1 + cnt + 1, cmp); if (check()) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = 1; i &lt;= m; ++i) cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; solve(); &#125; return 0;&#125; D. AB Graph Problem 给定结点数为 nnn 的有向完全图； 图上每一条边有一个属性值为 A / BA \\ / \\ BA / B; 询问是否可以找到长度为 kkk 的路径，使得路径所得字符串为回文串。 Analysis 思维 图为完全图，任意两点间有两条边； 分别讨论 kkk 为奇偶的情况： k%2==1k \\% 2 == 1k%2==1：对于任意两点，可能为 XXX…XXX \\dotsXXX… 或 XYXY…XYXXYXY \\dots XYXXYXY…XYX 的形式； k%2==0k \\% 2 == 0k%2==0：对于任意两点，可能为： XXXXXX 能成环； XYXYXY 讨论三点的情况： a⇔XYb a⇔XYa \\xLeftrightarrow[X]{Y} b \\ a \\xLeftrightarrow[X]{Y}aYX​b aYX​：可以构造出形如 XXYYXXYYXXYY 或 XYYXXYYXXYYX 的回文串； 若不满足，则必然为 XYXYXYXYXYXY 的路径，此时无解。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e3 + 7;int T;int n, m;char graph[MAXN][MAXN];int samech[2];int loopch[3];int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) cin &gt;&gt; graph[i][j]; if (m % 2 == 1) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = 0; i &lt;= m; ++i) cout &lt;&lt; i % 2 + 1 &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; continue; &#125; bool flg = false; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i!= j &amp;&amp; graph[i][j] == graph[j][i]) &#123; samech[0] = i; samech[1] = j; flg = true; break; &#125; &#125; if (flg) break; &#125; if (flg) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; for (int i = 0; i &lt;= m; ++i) cout &lt;&lt; samech[i % 2] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; else &#123; for (int i = 1; i &lt;= n; ++i) &#123; int cnt = 0; loopch[0] = i; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) continue; if (cnt == 0 &amp;&amp; graph[i][j] != graph[j][i]) loopch[++cnt] = j; if (cnt == 1 &amp;&amp; graph[i][j] != graph[j][i]) &#123; if (graph[i][loopch[1]] != graph[i][j]) &#123; loopch[++cnt] = j; flg = true; break; &#125; &#125; &#125; if (flg) break; &#125; if (flg) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; if (m % 4 == 0) &#123; int ans[4] = &#123;loopch[0], loopch[1], loopch[0], loopch[2]&#125;; for (int i = 0; i &lt;= m; ++i) cout &lt;&lt; ans[i % 4] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; else &#123; int ans[4] = &#123;loopch[1], loopch[0], loopch[2], loopch[0]&#125;; for (int i = 0; i &lt;= m; ++i) cout &lt;&lt; ans[i % 4] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; &#125; &#125; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125; E. Sorting Books","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"}]},{"title":"Talk about ACG and Mushoku Tensei","slug":"Talk-about-ACG-and-Mushoku-Tensei","date":"2021-02-05T10:16:55.000Z","updated":"2021-02-17T10:39:59.774Z","comments":true,"path":"2021/02/05/Talk-about-ACG-and-Mushoku-Tensei/","link":"","permalink":"https://noginonoka.github.io/2021/02/05/Talk-about-ACG-and-Mushoku-Tensei/","excerpt":"","text":"谈谈二次元业界与《无职转生》 写在前面 本文写于无职转生动画第四集，原作轻小说 24 卷完结后。本文作者以前 20 卷台译轻小说、前 4 集动画为基础，谈谈对当今二次元业界与《无职转生》的看法。内容包含部分剧透，请选择阅读。 异世界与无职转生 个人观点 《无职转生》是一部内容尚可且有深度的以异世界为题材的轻小说。动画方面《无职转生》画风优秀，甚至播放量（nico niconico \\ niconico nico）上超过 2020 12 月霸权热血番剧《咒术回战》（数据源于网络素材，未考证）。在世界观的设定上较为传统，主人公人物形象与部分剧情略有不妥引发争议，不适合少儿观看，但人物情感与剧情走向合情合理，可以说是一部不错的二次元异世界题材小说、番剧。 动画 截至已经播出的第四集，《无职转生》受到很多质疑，主要是以下内容： 男主前世是一名 30 岁无职在家的手冲肥宅； 转生后，男主（鲁迪乌斯）的父亲（保罗）在其母亲（赛妮丝）怀孕期间与其家女仆（莉莉娅）发生关系，婚内孕期出轨。 第一个内容是人物设定上的引人反感，小说作者观点上并没有对前世的生活方式有任何的赞同态度，鲁迪乌斯的前世是一个无业中年大叔，在校园期间收到霸凌，闭门不出，家人对其辱骂刁难，造就了其前世的性格与生活方式。可以说男主前世是一个可恶又可悲的人，对亲人、甚至是世间的一切都没有任何情感。这部分内容确实会引起部分人的反感与不适，但并不止于会上升至作者三观不正、作品三观不正这种级别。这部分的设定对后续剧情的发展也起到铺垫作用，可以说是鲁迪乌斯情感上的改变使得本作品奠定了感情基调。 第二个内容是剧情内容上的引人反感，婚内出轨是违背当今世界道德、公序良俗且是违反现今世界法律的行为。设定上保罗是一名花花公子，婚前和多名异性发生关系，后与信奉米里斯教（教义中含有一夫一妻制）赛妮丝结婚。对于保罗而言，这样的行为无疑是不合适的；对于鲁迪乌斯而言，其内心希望异世界的家庭不要分崩离析而编出了其父保罗胁迫女仆莉莉娅发生关系的谎言，希望自己的母亲能留下莉莉娅与其胎儿，使其母女不会因为路途中的危险丧命，并且希望家庭能得以延续。原作中，对赛妮丝的心理描写阐述了母亲察觉了鲁迪乌斯的内心对家庭的期望，并非是支持保罗出轨的行为。可以说这段剧情不合适且引人反感，是小说作者考虑不周，但小说作者在情节描写中充分说明了鲁迪乌斯与其母亲赛妮丝行为的原因，并且明确指出保罗犯下的大错，远非网络上部分歪曲剧情内容且只阐述部分情节的剧情与评论，如果说是保罗出轨的剧情是三观不正确有此事，但是小说作者对这保罗出轨的评价也是作品三观的一部分，是否能够直接简单的认为作品三观不正留给读者自行判断。 这一段剧情侧面反映了鲁迪乌斯外表看似小孩，内心实际上是一名缺少家庭的爱的成人。虽然剧情选择上并不合适，但是事件的过程与结果恰恰反映了底层人民对家庭的期盼。如果说小说部分情节是违背道德、违反法律的就足以被评价为作品三观不正，我想大部分犯罪小说、涉及情色的名著、以及很多阐述历史的书籍都会因此枪毙。 轻小说 本部分内容涉嫌剧透，请自行选择观看。 本部分内容涉嫌剧透，请自行选择观看。 本部分内容涉嫌剧透，请自行选择观看。 这部作品最主要的感情基调就是鲁迪乌斯对家人的爱，几乎全部的剧情发展都依赖于男主对家人的爱、为了守护家人而战斗的信念。鲁迪乌斯一共娶了三个妻子，在异世界中是符合设定的，在现实中显然是不可能存在的，曾有网络评论认为一个现代人到了异世界就理应纠正异世界的陋习，所以现代作品是否都不能描绘一夫多妻制的落后世界？同时要求男主是超级帅哥一己之力扭转世俗，简直毫无道理。鲁迪乌斯在作品中为每一位家人战斗、经历过无数失败，并不是一个异世界龙傲天男主角。如果设定上男主是个超级帅哥，穿越到异世界开挂征服无数妹子 (《带着智能手机闯荡异世界》) ，发出大家都是我的翅膀此番言论，看番人乐呵乐呵一笑了之，而本作男主娶妻成家守护家人，没有去为了女拳而战，就被评价为三观不正未免太过双标了。 诸多当今社会谴责的现象在以异世界为题材的番剧中多有体现，包括但不限于：奴隶制、一夫多妻制、种族歧视等。个人认为，作者没有推崇这些现象，而是以此为题材，在作品中提及解放奴隶、一夫一妻制（本作中的米里斯教）、与矮人或兽人等受到歧视的种族和平交往完全符合情理，恰是三观正的体现。 本作中，赛妮丝与其日后生下的女儿（诺伦）成为了米里斯教徒，体现了在落后异世界中产生了符合现代人的先进思想，合情合理，因为男主没有去改变异世界陋习而受到抨击，未免太过严苛。 个人观点，这方面的不理性讨论完全是某些怀有恶意的女拳团体故意带节奏，为了冲击包括本番以及整个二次元产业的恶意行为。 总结 本番是少有的作画高质量、感情有深度、剧情有起伏的异世界作品，虽然情节不适合少儿观看，并非子供向作品，但作为一个有判断力的成年人应该能判断出作品的价值导向。 个人预测，根据播放量与热度、这部动画会有第二季（盲猜第一季结束应该是刚被传送到魔大陆的情节），某些恶意评价、双标的女拳大概会大失所望，毕竟这些人还没有办法改变日本的动画产业与制作公司。 异世界与二次元 异世界题材的流行最初是源于《Re: 从零开始的异世界生活》动画首播于 2017年，该作品也是轻小说改编，随后三年动画界以异世界、转生、魔法世界等为题材仿佛成为了财富密码，好番与烂番都层出不穷，作画质量基本成为了播放量的下限，再度鞭尸《带着智能手机闯荡异世界》、《贤者之孙》；同时也产生了许多喂屎名作，如《盾之勇者成名录》；亦有许多以《因为太怕痛就全点防御力了。》、《我不是说了能力要平均值吗》、《熊熊勇闯异世界》为首的萌系作品出现。 第一类作品烂的没人冲、第二类作品悲惨男主设定宅们自己冲 (女拳会管这种作品？) ，第三类萌萌系女主人人爱，自然不会出圈；而在现今 2021 1月新番上映，出现了一部作画优秀、热度很高，且产生了部分争议情节的作品，拳击手们自然不会放弃机会，成功把本部作品冲出了圈，歪曲情节删减情节使得作品被扣上三观不正的帽子，可惜拳击手冲不到日本制片公司，令人遗憾，毕竟在微博女拳当道的现今，最好不要与其为敌 (笑) ，万一一言不合这些人顺带把所有历史人物、西方各种名著中的贵族全冲了。 后话 感谢阅读，如果看完了本文加深了你对该作品的愤怒，关我 P 事 (毕竟作者是社会底层人下人) 。希望本文能够帮助你更全面的了解《无职转生》的动画以及小说，并且你可以在了解作品内容后再有客观评价、客观看待对作品的不同看法、分辨出某些恶意的言论。文中举例的网络中对作品的评论与批评，皆为作者从各大论坛漫评中浏览概括而得，仅供参考。","categories":[{"name":"Tittle-Tattle","slug":"Tittle-Tattle","permalink":"https://noginonoka.github.io/categories/Tittle-Tattle/"}],"tags":[{"name":"ACGN","slug":"ACGN","permalink":"https://noginonoka.github.io/tags/ACGN/"}]},{"title":"Educational Codeforces Round 103 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-103-Rated-for-Div-2","date":"2021-02-04T12:20:18.000Z","updated":"2021-02-19T02:36:11.443Z","comments":true,"path":"2021/02/04/Educational-Codeforces-Round-103-Rated-for-Div-2/","link":"","permalink":"https://noginonoka.github.io/2021/02/04/Educational-Codeforces-Round-103-Rated-for-Div-2/","excerpt":"","text":"A. K-divisible Sum Problem 将 kkk 的整数倍分成正整数 nnn 份，求所有份数中最大值的最小值为多少。 Analysis 思维 求出超过 nnn 的最小值 mkmkmk。 代码 被 hack 了 原因是用循环代替了除法… 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl &quot;\\n&quot;int T;int n, k;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; k; k = ceil(1.0 * n / k) * k; int ans = ceil(1.0 * k / n); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; B. Inflation Problem 给定一个长度为 nnn 的数组 aaa; 修改数组中的值，使得 ai∑j=1i−1aj≤k\\dfrac{a_i}{\\sum\\limits_{j = 1}^{i - 1}a_j} \\le kj=1∑i−1​aj​ai​​≤k； 求修改的总数值绝对值的最小值。 Analysis 贪心 前缀和 只修改 a1a_1a1​。 C. Longest Simple Cycle Problem 给定 nnn 条线段, cic_ici​ 表示线段节点数，第 222 条线段起 1−ai1 - a_i1−ai​ 与 ci−bic_i - b_ici​−bi​ 建边； 求图中的简单环。 Analysis 贪心 DP 当 ai=bia_i = b_iai​=bi​ 时，一个环结束； 当 ai≠bia_i \\ne b_iai​​=bi​ 时，求当前成环长度与从当前位置建立新环 abs(ai−bi)abs(a_i - b_i)abs(ai​−bi​) 长度的最值。 Code 当时降智打击，写了个 O(n2)O(n^2)O(n2) 的算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXN = 1e5 + 7;int T;int n;int c[MAXN];int a[MAXN];int b[MAXN];int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; c[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; b[i]; int tmp = 0; int ans = 0; bool flg = false; for (int i = 2; i &lt;= n; ++i) &#123; if (flg == false) &#123; tmp += abs(a[i] - b[i]); tmp += 2; flg = true; &#125; else &#123; tmp += abs(1 - min(a[i], b[i])) + abs(c[i - 1] - max(a[i], b[i])); if (a[i] == b[i]) &#123; ans = max(ans, tmp); tmp = 2; continue; &#125; ans = max(ans, tmp + abs(a[i] - b[i])); tmp += 2; tmp = max(tmp, abs(a[i] - b[i]) + 2); &#125; &#125; if (flg == true) &#123; tmp += c[n] - 1; ans = max(ans, tmp); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; D. Journey Problem 一维平面上有 [0,n][0, n][0,n] 共 n+1n + 1n+1 个点； i i+1i \\ \\ i + 1i i+1 之间存在一条边； 初始状态 L RL \\ RL R 表示边的方向为向左 \\ 右； 跳转到另一个点时，所有的边反向； 求从任意点开始，最多可达的点数。 Analysis 贪心 每一个点可达的位置仅在其连续的 LRLRLRLRLRLR 或 RLRLRLRLRLRL 段内； 特殊情况为 i=0, i=ni = 0, \\ i = ni=0, i=n 与该点为上述连续段的端点的情况； 分类讨论即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 3e5 + 7;int T;int n;string s;int sum[MAXN];int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; cin &gt;&gt; s; sum[0] = sum[1] = 0; for (int i = 1; i &lt; n; ++i) &#123; if (s[i] != s[i - 1]) sum[i + 1] = sum[i] + 1; else sum[i + 1] = 0; &#125; bool flg = true; for (int i = n - 1; i &gt; 0; --i) &#123; if (flg) &#123; if (!sum[i]) flg = false; sum[i] = max(sum[i + 1], sum[i]); &#125; else flg = true; &#125; sum[0] = sum[1]; for (int i = 0; i &lt;= n; ++i) &#123; if (i == 0) &#123; if (s[i] == &#x27;R&#x27;) cout &lt;&lt; sum[i] + 2 &lt;&lt; &quot; &quot;; else cout &lt;&lt; 1 &lt;&lt; &quot; &quot;; &#125; else if (i == n) &#123; if (s[n - 1] == &#x27;L&#x27;) cout &lt;&lt; sum[n] + 2 &lt;&lt; endl; else cout &lt;&lt; 1 &lt;&lt; endl; &#125; else &#123; if (s[i - 1] == &#x27;R&#x27; &amp;&amp; s[i] == &#x27;L&#x27;) cout &lt;&lt; 1 &lt;&lt; &quot; &quot;; else if (s[i - 1] == &#x27;R&#x27; &amp;&amp; s[i] == &#x27;R&#x27;) cout &lt;&lt; sum[i + 1] + 2 &lt;&lt; &quot; &quot;; else if (s[i - 1] == &#x27;L&#x27; &amp;&amp; s[i] == &#x27;L&#x27;) cout &lt;&lt; sum[i] + 2 &lt;&lt; &quot; &quot;; else cout &lt;&lt; sum[i] + 2 &lt;&lt; &quot; &quot;; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"},{"name":"Greedy","slug":"Greedy","permalink":"https://noginonoka.github.io/tags/Greedy/"}]},{"title":"2020 ICPC Asia Jinan Regional Contest","slug":"2020-ICPC-Asia-Jinan-Regional-Contest","date":"2021-02-01T16:10:30.000Z","updated":"2021-02-17T10:39:25.647Z","comments":true,"path":"2021/02/02/2020-ICPC-Asia-Jinan-Regional-Contest/","link":"","permalink":"https://noginonoka.github.io/2021/02/02/2020-ICPC-Asia-Jinan-Regional-Contest/","excerpt":"","text":"M. Cook Pancakes! Problem 给定 nnn 个煎饼，每个煎饼要煎两次； 一分钟最多同时煎 kkk 个； 求煎完所有的煎饼需要多久。 Analysis 思维 t=⌈2∗n/k⌉t = \\lceil 2 * n / k \\rceilt=⌈2∗n/k⌉ C. Stone Game Problem 给定 a1, a2, a3a_1,\\ a_2 ,\\ a_3a1​, a2​, a3​ 分别表示数量为 1, 2, 31 ,\\ 2 ,\\ 31, 2, 3 的石子堆； 每一次合并需要支付 (i%3)(j%3)(i \\% 3)(j \\% 3 )(i%3)(j%3) 的费用 求将所有煎饼堆合并为一堆所需的最小费用。 Analysis 思维 贪心 显然 a3a_3a3​ 与任意堆合并均不需要费用； 首先，a1 a2a_1 \\ a_2a1​ a2​ 合并需要支付 222 费用可以转化为 a3a_3a3​ 堆； 将剩余的 a1 / a2a_1 \\ / \\ a_2a1​ / a2​ 取 23\\frac{2}{3}32​，将其合并为另一类型的堆。 D. Fight against involution Problem 给定 nnn 个区间 [l, r][l,\\ r][l, r]； 原区间按 rrr 降序排序得到的位次花费 ∑ri\\sum r_i∑ri​； 求一个满足每个花费均在原区间且每区间位次不劣与原位次的排序所需要的总花费。 Analysis 贪心 模拟 对区间按右端点从小到大排序 顺序遍历区间，维护所有所选值的最大值并与当前可行值的最小值比较，求出花费。 G. Xor Transformation 略 J. Tree Constructer Problem 给定 nnn 个节点的树，构造当且仅当两点是任一边端点 i ji \\ ji j时，权值满足 i∣j=260−1i | j = 2 ^{60} - 1i∣j=260−1 的点权。 Analysis DFS 思维 一次 DFS 将树节点分为度为 奇 / 偶 两类； 规定两类的最后两位分别为 10/0110 / 0110/01； 选择数量较少的一类点（显然不超过 505050）将 585858 位二进制位赋值为 111…0…1+10111\\dots 0 \\dots1 + 10111…0…1+10； 第二次 DFS 为其余点赋值，将所有与其连接的节点的前 585858 位中的 000 位赋 111； 显然，对于任意两相同类型节点求或后 ≠260−1\\neq 2^{60} - 1​=260−1，两不直接相连的节点求或后亦不合Problem。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl &quot;\\n&quot;const int MAXN = 100 + 7;int n;struct Edge&#123; int nxt; int to;&#125;edge[2 * MAXN];int cntEdge;int head[MAXN];void init()&#123; cntEdge = 0; memset(head, 0, sizeof(head));&#125;void addEdge(int u, int v)&#123; ++cntEdge; edge[cntEdge].to = v; edge[cntEdge].nxt = head[u]; head[u] = cntEdge;&#125;int dep[MAXN];int cnt1, cnt2;int val[MAXN];void dfs(int u, int fa)&#123; dep[u] = dep[fa] + 1; if (dep[u] % 2 == 1) ++cnt1; else ++cnt2; for (int i = head[u]; i; i = edge[i].nxt) &#123; int v = edge[i].to; if (v != fa) dfs(v, u); &#125;&#125;bool flg;void setVal()&#123; if (cnt2 &lt; cnt1) flg = true; else flg = false; int tmp = 1; for (int i = 1; i &lt;= n; ++i) &#123; if ((flg &amp;&amp; dep[i] % 2 == 0) || (!flg &amp;&amp; dep[i] % 2 == 1)) &#123; val[i] = (1LL &lt;&lt; 58) - 1 - tmp; val[i] &lt;&lt;= 2; val[i] |= 1; tmp &lt;&lt;= 1; &#125; &#125;&#125;void dfs2(int u, int fa)&#123; if (flg &amp;&amp; dep[u] % 2 == 1) val[u] = val[u] | ((1LL &lt;&lt; 60) - val[fa] - 1); if ((!flg &amp;&amp; dep[u] % 2 == 0)) val[u] = val[u] | (1LL &lt;&lt; 60) - val[fa] - 1; for (int i = head[u]; i; i = edge[i].nxt) &#123; int v = edge[i].to; if (v != fa) &#123; if (flg &amp;&amp; dep[u] % 2 == 1) val[u] = val[u] | ((1LL &lt;&lt; 60) - val[v] - 1); if ((!flg &amp;&amp; dep[u] % 2 == 0)) val[u] = val[u] | (1LL &lt;&lt; 60) - val[v] - 1; dfs2(v, u); &#125; &#125;&#125;void solve()&#123; init(); memset(dep, 0, sizeof(dep)); cin &gt;&gt; n; int u, v; for (int i = 1; i &lt;= n - 1; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); addEdge(v, u); &#125; dfs(1, 0); setVal(); if (flg &amp;&amp; dep[1] % 2 == 0 || !flg &amp;&amp; dep[1] % 2 == 1) dfs2(1, 0); if (!flg &amp;&amp; dep[1] % 2 == 0 || flg &amp;&amp; dep[1] % 2 == 1) dfs2(edge[head[1]].to, 0); for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; val[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); solve(); return 0;&#125; L. Bit Sequence A. Matrix Equation","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://noginonoka.github.io/tags/ICPC/"}]},{"title":"Codeforces Round #698 (Rated for Div. 2 / Div. 1)","slug":"Codeforces-Round-698-Rated-for-Div-2-Div-1","date":"2021-01-31T10:19:50.000Z","updated":"2021-02-16T13:55:00.006Z","comments":true,"path":"2021/01/31/Codeforces-Round-698-Rated-for-Div-2-Div-1/","link":"","permalink":"https://noginonoka.github.io/2021/01/31/Codeforces-Round-698-Rated-for-Div-2-Div-1/","excerpt":"","text":"A. Nezzar and Colorful Balls Problem 给定长度为 nnn 的单调不减序列 aaa，使用 mmm 种颜色给序列染色，保证每种颜色所构成的序列严格递增； 求 mmm 的最小值。 Analysis 贪心 求序列中相同的数的最大个数。 B. Nezzar and Lucky Number Problem [1, 9][1,\\ 9][1, 9] 中 有一个幸运数字 ddd； 给定 nnn， 询问是否可能将其分解成若干个十进制整数数位中包含 ddd 的数之和。 Analysis 贪心 三种情况： nnn 本身包含 ddd n=10p+q⋅dn = 10p+ q \\cdot dn=10p+q⋅d n=d⋅10p+qn = d \\cdot 10p + qn=d⋅10p+q 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1e4 + 7;int T;int q, d;int a[MAXN];int ok[13];bool check(int x, int d)&#123; if (ok[x % 10] &amp;&amp; ok[x % 10] &lt;= x) return true; int tmp = x; while (tmp) &#123; if (tmp % 10 == d) return true; tmp /= 10; &#125; int cnt = x / (d * 10); int res = 0; int now = 9; tmp = cnt; while (tmp) &#123; res += (tmp % 10) * now; now = now * 10 + 9; tmp /= 10; &#125; tmp = x % d; if (res &gt; tmp) return true; return false;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; q &gt;&gt; d; for (int i = 1; i &lt;= q; ++i) &#123; cin &gt;&gt; a[i]; &#125; int tmp = d; memset(ok, 0, sizeof(ok)); while (true) &#123; if (ok[tmp % 10] == 0) ok[tmp % 10] = tmp; else break; tmp += d; &#125; for (int i = 1; i &lt;= q; ++i) &#123; if (check(a[i], d)) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; C. Nezzar and Symmetric Array Problem 给定长度为 2n2n2n 的序列，序列中每种元素仅出现一次，且满足 ∀ai∈a, ∃aj=−ai\\forall a_i \\in a, \\ \\exist a_j = - a_i∀ai​∈a, ∃aj​=−ai​； 给定数组 ddd，满足 di=∑j=12n∣ai−aj∣d_i = \\sum\\limits_{j = 1}^{2n} |a_i - a_j|di​=j=1∑2n​∣ai​−aj​∣； 判断数组 ddd 是否合法。 Analysis 思维 对于每一个 aia_iai​ 与其对于的 aja_jaj​，满足 di=djd_i = d_jdi​=dj​； 考查一个正的 amax⁡a_{\\max}amax​，满足 ∣amax⁡−aj∣+∣amax⁡+aj∣=2amax⁡|a_{\\max} - a_j| + |a_{\\max} + a_j| = 2 a_{\\max}∣amax​−aj​∣+∣amax​+aj​∣=2amax​； 故对于第 kkk 大的数 aka_kak​，满足 dk=2∑j=k+1naj+2k⋅akd_k = 2 \\sum\\limits_{j = k + 1}^{n} a_j+ 2k \\cdot a_kdk​=2j=k+1∑n​aj​+2k⋅ak​； 对数组排序后遍历数组判断是否合法。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl &quot;\\n&quot;const int MAXN = 2e5 + 7;int T;int n;int d[MAXN];int a[MAXN];int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= 2 * n; ++i) &#123; cin &gt;&gt; d[i]; &#125; sort(d + 1, d + 2 * n + 1, greater&lt;int&gt;()); bool flg = true; int sum = 0; int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (d[2 * i] != d[2 * i - 1]) &#123; flg = false; break; &#125; if (d[2 * i] % 2) &#123; flg = false; break; &#125; if ((d[2 * i] - sum) % (2 * n - cnt) != 0) &#123; flg = false; break; &#125; else &#123; a[i] = (d[2 * i] - sum) / (2 * n - cnt); if (a[i] &lt;= 0 || a[i] == a[i - 1]) &#123; flg = false; break; &#125; sum += 2 * a[i]; cnt += 2; &#125; &#125; if (flg) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; D. Nezzar and Board Problem 给定长度为 nnn 的序列 aaa； 选取任意 ai aja_i \\ a_jai​ aj​，添加 2ai−aj2a_i - a_j2ai​−aj​ 进入序列； 进行若干次操作，判断是否可以得到 mmm。 Analysis 数论 Let’s first assume that x1=0x_1=0x1​=0 ( Otherwise, we could subtract x1x_1x1​ for x1,x2,…,xnx_1,x_2,…,x_nx1​,x2​,…,xn​ and kkk ). We will now prove that the answer is “YES” if and only if k can be divided by g=gcd(x2,x3,…,xn)g=gcd(x_2,x_3,…,x_n)g=gcd(x2​,x3​,…,xn​). One direction is straightforward. Note that any number written on the board should be divisible by ggg, which follows from the fact that g∣x,g∣y⇒g∣2x−yg|x,g|y \\Rightarrow g|2x-yg∣x,g∣y⇒g∣2x−y. It only remains to prove that for any xxx divisible by ggg, we could write down xxx on the board. We will prove it by induction on nnn. Base case (n=2)(n=2)(n=2) is obvious. Let g0=gcd(x2,x3,…,xn−1)g_0=gcd(x_2,x_3,…,x_{n-1})g0​=gcd(x2​,x3​,…,xn−1​). By Bézout’s Theorem, there exists integers s,ts,ts,t such that g0s−xnt=gg_0s-x_nt=gg0​s−xn​t=g. By induction, we could write down g0g_0g0​ on the board, and trivially xntx_ntxn​t can be written on the board. Therefore, we could write down ggg applying operation recursively. 官方Code 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std; const int maxn=200007;int t;int n,k;int x[maxn]; signed main()&#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); cin&gt;&gt;t; while (t--)&#123; cin&gt;&gt;n&gt;&gt;k; for (int i=0;i&lt;n;++i) cin&gt;&gt;x[i]; sort(x,x+n); int g=0; for (int i=1;i&lt;n;++i)&#123; g=__gcd(g,x[i]-x[0]); &#125; if ((k-x[0])%g) cout&lt;&lt;&quot;NO\\n&quot;; else cout&lt;&lt;&quot;YES\\n&quot;; &#125; return 0;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"},{"name":"Math Theory","slug":"Math-Theory","permalink":"https://noginonoka.github.io/tags/Math-Theory/"}]},{"title":"2020 ICPC Asia Nanjing Regional Contest","slug":"2020-ICPC-Asia-Nanjing-Regional-Contest","date":"2021-01-30T06:56:22.000Z","updated":"2021-02-17T10:39:32.839Z","comments":true,"path":"2021/01/30/2020-ICPC-Asia-Nanjing-Regional-Contest/","link":"","permalink":"https://noginonoka.github.io/2021/01/30/2020-ICPC-Asia-Nanjing-Regional-Contest/","excerpt":"","text":"K. K Co-prime Permutation Problem 求 [1,n][1, n][1,n] 的一个序列 aaa，其中满足 gcd(ai,i)==1gcd(a_i, i) == 1gcd(ai​,i)==1 的个数为 kkk。 Analysis 构造 显然 111 在任何位置，必然为一个满足条件的解，故，当 k&lt;1∣∣k&gt;nk &lt; 1 || k &gt; nk&lt;1∣∣k&gt;n 时，不存在满足条件的序列； 当 kkk 为奇数时，从 222 开始，将 ai ai+1a_i \\ a_{i+1}ai​ ai+1​ 互换； 当 kkk 为偶数时，从 111 开始，将 ai ai+1a_i \\ a_{i+1}ai​ ai+1​ 互换。 L. Let’s Play Curling Problem a ba \\ ba b 数组中各有 n mn \\ mn m 个点，表示数轴上两组点坐标； 对于 ccc 满足 i∈a, ∀j∈b, ∣c−ai∣&lt;∣c−bj∣i \\in a ,\\ \\forall j \\in b ,\\ |c - a_i| &lt; |c - b_j|i∈a, ∀j∈b, ∣c−ai​∣&lt;∣c−bj​∣； 求满足条件的点的最大个数。 Analysis 思维 考虑在数轴上的点，bbb 中的点将数轴分为 m+1m + 1m+1 个线段； 对于任意 ccc 满足条件的点即为： ccc 所在的线段中，aaa 中点的个数。 F. Fireworks Problem 制造一个烟花需要时间 nnn，燃放所有烟花需要时间 mmm，一个烟花为完美烟花的概率为 p′=p×10−4p&#x27; = p \\times 10^{-4}p′=p×10−4； 直至燃放出一个完美烟花为止，求需求时间期望的最小值。 Analysis 概率论 函数最值 三分查找 制作 kkk 个烟花并点燃所需时间为 k⋅n+mk \\cdot n + mk⋅n+m，存在完美烟花的概率为 1−(1−p′)k1 - (1 - p&#x27;)^k1−(1−p′)k； 显然，对于每一次燃放，均为独立事件，故存在最优 kkk，服从几何分布 P=1−(1−p′)kP = 1 - (1 - p&#x27;)^kP=1−(1−p′)k; 几何分布期望为 E(x)=k⋅n+m1−(1−p′)kE(x) = \\dfrac{k \\cdot n + m}{1 - (1 - p&#x27;)^k}E(x)=1−(1−p′)kk⋅n+m​； 两次求导发现，该函数为单峰函数，有最小值。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const double eps = 1e-6;double getPow(double a, int b)&#123; double res = 1; while (b) &#123; if (b &amp; 1) res *= a; a *= a; b &gt;&gt;= 1; &#125; return res;&#125;int T;int n, m, p;double p0;double ans;double calc(int k)&#123; return ((double)k * n + m) / (1.0 - getPow(1.0 - p0, k));&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; ans = (double)0x3f3f3f3f3f3f; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; p0 = (double) p * (1e-4); int l = 1, r = INF; while (l &lt; r) &#123; int mid1 = l + (r - l) / 3; int mid2 = r - (r - l) / 3; double ans1 = calc(mid1); double ans2 = calc(mid2); ans = min(ans, min(ans1, ans2)); if (fabs(ans1 - ans2) &gt; 1e-8 &amp;&amp; ans1 &lt; ans2) r = mid2 - 1; else if (fabs(ans1 - ans2) &gt; 1e-8 &amp;&amp; ans1 &gt; ans2) l = mid1 + 1; else break; &#125; printf(&quot;%.9lf\\n&quot;, ans); &#125; return 0;&#125; M. Monster Hunter Problem 一棵 nnn 个节点的树，以节点 111 为根，每个节点上有一个 hpihp_ihpi​ 血量的怪物； 击败一个怪物需要付出力量 P=hpi+∑jhpjP = hp_i + \\sum\\limits_{j} hp_jP=hpi​+j∑​hpj​，其中 jjj 为以 iii 为父节点的所有节点； 现有一操作 QQQ 可将任一节点上的怪物删去且所需 P=0P = 0P=0； 求执行 k∈[0, n]k \\in [0,\\ n]k∈[0, n] 次操作 QQQ 分别最少需要多少力量 PPP。 Analysis 树型 DP dp[i][k][0/1]dp[i][k][0/1]dp[i][k][0/1] 表示以节点 iii 为根节点的子树，保留 kkk 个节点，根节点 0/10 / 10/1 是否保留的条件下，最少所需的力量； 状态转移方程： dp[x][i+j][0]=min(dp[x][i+j][0],min(dp[y][j][0],dp[y][j][1])+dp[x][i][0]);dp[x][i+j][1]=min(dp[x][i+j][1],min(dp[y][j][0],dp[y][j][1]+hp[y])+dp[x][i][1]);\\begin{array}{l} dp[x][i + j][0] = min(dp[x][i + j][0], min(dp[y][j][0], dp[y][j][1]) + dp[x][i][0]); \\\\ dp[x][i + j][1] = min(dp[x][i + j][1], min(dp[y][j][0], dp[y][j][1] + hp[y]) + dp[x][i][1]); \\end{array} dp[x][i+j][0]=min(dp[x][i+j][0],min(dp[y][j][0],dp[y][j][1])+dp[x][i][0]);dp[x][i+j][1]=min(dp[x][i+j][1],min(dp[y][j][0],dp[y][j][1]+hp[y])+dp[x][i][1]);​ Code 注意初始化全部 dp 数组会导致 TLE。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXN = 2e3 + 7;int T;int n;int hp[MAXN];int dp[MAXN][MAXN][2];vector&lt;int&gt; graph[MAXN];int cnt[MAXN];void init()&#123; for (int i = 0; i &lt;= n; ++i) for (int j = 0; j &lt;= n; ++j) dp[i][j][0] = dp[i][j][1] = 0x3f3f3f3f3f3f3f3f; for (int i = 1; i &lt;= n; ++i) graph[i].clear();&#125;void dfs(int x)&#123; dp[x][0][0] = 0; dp[x][1][1] = hp[x]; cnt[x] = 1; for (auto it : graph[x]) &#123; dfs(it); for (int i = cnt[x]; i &gt;= 0; --i) &#123; for (int j = cnt[it]; j &gt;= 0; --j) &#123; dp[x][i + j][0] = min(dp[x][i + j][0], min(dp[it][j][0], dp[it][j][1]) + dp[x][i][0]); dp[x][i + j][1] = min(dp[x][i + j][1], min(dp[it][j][0], dp[it][j][1] + hp[it]) + dp[x][i][1]); &#125; &#125; cnt[x] += cnt[it]; &#125;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; init(); for (int i = 2; i &lt;= n; ++i) &#123; int fa; cin &gt;&gt; fa; graph[fa].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; hp[i]; &#125; dfs(1); for (int i = n; i &gt;= 0; --i) &#123; cout &lt;&lt; min(dp[1][i][0], dp[1][i][1]) &lt;&lt; (i == 0 ? &#x27;\\n&#x27; : &#x27; &#x27;)); &#125; &#125; return 0;&#125; E. Evil Coordinate Problem 二维坐标平面，初始位置位于坐标原点，UDLR 分别表示上下左右移动一格； 给定地雷位置与操作序列； 问是否能对原序列排序后使得新序列不经过地雷位置，若存在输出序列。 Analysis 思维 构造 H. Harmonious Rectangle Problem n×mn \\times mn×m 的方格填入 0 1 20 \\ 1 \\ 20 1 2 三种数字； 求存在 444 坐标构成矩阵 [ai,jai,nam,jam,n]\\begin{bmatrix} a_{i,j} &amp; a_{i, n} \\\\ a_{m,j} &amp; a_{m, n} \\end{bmatrix} [ai,j​am,j​​ai,n​am,n​​] 满足： [xxyy] or [xyxy]\\begin{bmatrix} x &amp; x \\\\ y &amp; y \\end{bmatrix} \\ or \\ \\begin{bmatrix} x &amp; y \\\\ x &amp; y \\end{bmatrix} [xy​xy​] or [xx​yy​] Code 思维 构造 打表 0 1 20 \\ 1 \\ 20 1 2 构成的矩阵 A2,1A_{2,1}A2,1​ 至多只有 777 种不同情况，只需要打表出 7×77 \\times 77×7 以内的所有可行情况。","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"https://noginonoka.github.io/tags/ICPC/"},{"name":"Probability Theory","slug":"Probability-Theory","permalink":"https://noginonoka.github.io/tags/Probability-Theory/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://noginonoka.github.io/tags/Dynamic-Programming/"}]},{"title":"Codeforces Round #696 (Rated for Div.2)","slug":"Codeforces-Round-696-Rated-for-Div.2","date":"2021-01-21T11:41:29.000Z","updated":"2021-02-10T10:33:39.211Z","comments":true,"path":"2021/01/21/Codeforces-Round-696-Rated-for-Div.2/","link":"","permalink":"https://noginonoka.github.io/2021/01/21/Codeforces-Round-696-Rated-for-Div.2/","excerpt":"","text":"QAQ −71-71−71 A. Puzzle From the Future Problem 定义二进制和 (Sum) 运算： 给定二进制字符串 a ba \\ ba b； 按位加和成字符串 ccc； 字符串 ccc 中，对于连续且相同的字符 iii 合并成一个字符 iii，得到新字符串 ddd； a+b=da + b = da+b=d 给定字符串长 nnn，给定字符串 bbb； 求一长度为 nnn 的字符串 aaa 使得 a+ba + ba+b 最大； Analysis 贪心 保证没有连续的数被合并； B. Different Divisors Problem 给定正整数 d≤10000d \\le 10000d≤10000 求正整数 aaa 满足所有因数 (≥4)(\\ge 4)(≥4) 两两之差 ≥d\\ge d≥d； Analysis 贪心 考虑因数 p={1, (1+d), (1+2d), (1+d)∗(1+2d)}p = \\{ 1 ,\\ (1+d) ,\\ (1 + 2d) ,\\ (1+d)*(1 + 2d) \\}p={1, (1+d), (1+2d), (1+d)∗(1+2d)}，若 (1+d) (1+2d)(1+d) \\ (1 + 2d)(1+d) (1+2d) 不为素数，则必然存在其他因数，不满足 pi−pi−1&lt;dp_i - p_{i - 1} &lt; dpi​−pi−1​&lt;d； 故，所求正整数有且只有 444 个因数 pip_ipi​，且 p2p_2p2​ 与 p3p_3p3​ 均为质数，a=p2∗p3=p4a = p_2 * p_3 = p_4a=p2​∗p3​=p4​。 C. Array Destruction Problem 给定长度为 2n (n≤1000)2n \\ (n \\le 1000)2n (n≤1000) 的数组 aaa； 选择一个正整数 xxx，从数组中选择 ai+aj=xa_i + a_j = xai​+aj​=x，删去两数，并使 x=max⁡ai,ajx = \\max{a_i, a_j}x=maxai​,aj​，重复此操作使得 aaa 中元素全部被删除； 若能够成功删除输出 xxx 与操作序列。 Analysis 暴力 贪心 复杂度：O(2n2log⁡(n))O(2n^2\\log(n))O(2n2log(n)) 枚举所有的 xxx，若可行，每次较大数必然为集合中最大的剩余元素，检查相应的较小数是否存在（setsetset 维护）。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int T;int n;vector&lt;int&gt; a;vector&lt;pair&lt;int, int&gt; &gt; ans;bool check(int x)&#123; ans.clear(); multiset&lt;int&gt; se; for (auto &amp;it : a) se.insert(it); for (int i = 1; i &lt;= n; ++i) &#123; auto it1 = se.end(); --it1; int y = x - *it1; se.erase(it1); auto it2 = se.find(y); if (it2 == se.end()) return false; ans.push_back(&#123;x - y, y&#125;); se.erase(it2); x = max(x - y, y); &#125; return true;&#125;void solve()&#123; sort(a.begin(), a.end()); for (int i = 0; i &lt; 2 * n - 1; ++i) &#123; int x = a[2 * n - 1] + a[i]; if (check(x)) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; cout &lt;&lt; x &lt;&lt; endl; for (auto &amp;it : ans) cout &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; return;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; a.clear(); for (int i = 1; i &lt;= 2 * n; ++i) &#123; int tmp; cin &gt;&gt; tmp; a.push_back(tmp); &#125; solve(); &#125; return 0;&#125; D. Cleaning Problem 给定长度为 n (≤200000)n \\ (\\le 200000)n (≤200000) 的正整数数组； 执行操作： 交换两个相邻的数（不超过一次）； 相邻的两个数同时减去 iii，两数均不能为负； 判断是否能消去所有的数； Analysis 思维、前缀和 预处理每一位上从前往后消除的数为 a1, a2−a1, a3−(a2−a1), …a_1,\\ a_2 - a_1,\\ a_3 - (a_2 - a_1),\\ \\dotsa1​, a2​−a1​, a3​−(a2​−a1​), …，从后往前同理； 预处理数组前缀和与后缀和后，枚举所有可能交换的数对： 交换数对 ai, ai+1a_i, \\ a_{i + 1}ai​, ai+1​ 若可以解决，对于区间 [1, i−1] [i+2, n][1,\\ i - 1] \\ [i + 2,\\ n][1, i−1] [i+2, n] 内将所有的数合并，记为 prei−1, sufi+2pre_{i - 1} ,\\ suf_{i + 2}prei−1​, sufi+2​ 均 ≥0\\ge 0≥0； 且满足：ai+1−prei−1=ai−sufi+2a_{i + 1} - pre_{i - 1} = a_i - suf_{i + 2}ai+1​−prei−1​=ai​−sufi+2​。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXN = 2e5 + 7;int T;int n;int a[MAXN];int pre[MAXN], suf[MAXN];int pos1, pos2;bool flg;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; pos1 = pos2 = -1; flg = false; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; pre[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; pre[i] = a[i] - pre[i - 1]; if (pre[i] &lt; 0) &#123; pos1 = i; break; &#125; &#125; suf[n + 1] = 0; for (int i = n; i; --i) &#123; suf[i] = a[i] - suf[i + 1]; if (suf[i] &lt; 0) &#123; pos2 = i; break; &#125; &#125; if (pre[n] == 0 &amp;&amp; pos1 == -1) flg = true; else &#123; for (int i = ((pos2 != -1 &amp;&amp; pos2 != 1) ? pos2 - 1 : 1); i &lt;= ((pos1 != -1 &amp;&amp; pos1 != n) ? pos1 : n - 1); ++i) &#123; if (pre[i] &gt;= 0 &amp;&amp; pre[i] == suf[i + 1]) &#123; flg = true; break; &#125; else &#123; if (a[i + 1] - pre[i - 1] &gt;= 0 &amp;&amp; a[i + 1] - pre[i - 1] == a[i] - suf[i + 2]) &#123; flg = true; break; &#125; &#125; &#125; &#125; if (flg) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; E. What Is It? Problem [1, n][1,\\ n][1, n] 的一个排列，对排列进行如下操作： 选定 i, ji, \\ ji, j 满足 pj=ip_j = ipj​=i，交换 pi, pjp_i,\\ p_jpi​, pj​ 消耗 (j−i)2(j - i)^2(j−i)2 的费用； 进行无限次操作后使得排列顺序排序，求费用最大的排列与排列的操作。 Analysis 构造 由于 pj=ip_j = ipj​=i ，每次操作必然使得一个元素到达他的位置，故至多进行 n−1n - 1n−1 次操作； 考察贡献为 (n−k)2(n - k)^2(n−k)2 的最大操作数： (n−1)2(n - 1)^2(n−1)2：交换 1, n1,\\ n1, n 至多一次； (n−2)2(n - 2)^2(n−2)2：交换 (1, n−1), (2, n)(1,\\ n - 1),\\ (2,\\ n)(1, n−1), (2, n) 至多两次； … 逆序这些操作，构造原序列。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int MAXN = 2E5 + 7;int T;int n;int ans;int a[MAXN];vector&lt;pair&lt;int, int&gt; &gt; sol;void init(int n)&#123; sol.clear(); for (int i = 1; i &lt;= n; ++i) a[i] = i;&#125;void solve(int n)&#123; ans = 0; int dlt = 1; int cnt = 0; while ((++cnt) &lt;= n - 1) &#123; if (cnt == 1) &#123; swap(a[1], a[n]); sol.push_back(&#123;1, n&#125;); ans += (n - 1) * (n - 1); &#125; else &#123; swap(a[(++dlt)], a[n]); sol.push_back(&#123;dlt, n&#125;); ans += (n - dlt) * (n - dlt); if ((++cnt) &lt;= n - 1) &#123; swap(a[1], a[n - dlt + 1]); sol.push_back(&#123;n - dlt + 1, 1&#125;); ans += (n - dlt) * (n - dlt); &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; cout &lt;&lt; (n - 1) &lt;&lt; endl; for (int i = n - 2; i &gt;= 0; --i) &#123; cout &lt;&lt; sol[i].first &lt;&lt; &quot; &quot; &lt;&lt; sol[i].second &lt;&lt; endl; &#125;&#125;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n; init(n); solve(n); &#125; return 0;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"}]},{"title":"Educational Codeforces Round 102 (Rated for Div.2)","slug":"Educational-Codeforces-Round-102-Rated-for-Div-2","date":"2021-01-18T13:18:00.000Z","updated":"2021-02-17T10:39:45.897Z","comments":true,"path":"2021/01/18/Educational-Codeforces-Round-102-Rated-for-Div-2/","link":"","permalink":"https://noginonoka.github.io/2021/01/18/Educational-Codeforces-Round-102-Rated-for-Div-2/","excerpt":"","text":"A. Replacing Elements 传送门 Problem 给定长度为 nnn 的正整数数组； 选择两两不等的三个数 i j ki \\ j \\ ki j k 替换 aia_iai​ 使得 ai=aj+aka_i = a_j + a_kai​=aj​+ak​； 使得数组中所有元素 ≤d\\le d≤d； t≤2000t \\le 2000t≤2000 组输入，其中 3≤n≤100, 1≤d≤1003 \\le n \\le 100, \\ 1 \\le d \\le 1003≤n≤100, 1≤d≤100。 Analysis 贪心 对数组按升序排序，判断 a1+a2≤da_1 + a_2 \\le da1​+a2​≤d。 B. String LCM 传送门 Problem 定义 s⋅k=s+⋯+s=ts \\cdot k = s + \\dots + s = ts⋅k=s+⋯+s=t 则 sss 整除 ttt; 给定两字符串 s ts \\ ts t，判断是否存在两字符串的最小公倍数； q≤2000q \\le 2000q≤2000 组输入，字符串长 ∣s∣, ∣t∣≤20|s|, \\ |t| \\le 20∣s∣, ∣t∣≤20。 Analysis 暴力 判断较小串 ttt 的每个子串是否为 GCDGCDGCD； C. No More Inversions 传送门 Problem 给定长度为 kkk 的递增排列； 将其按如下方式扩充 1, 2, 3, 4, …,k, k−1, k−2, …1, \\ 2, \\ 3, \\ 4, \\ \\dots , k, \\ k - 1, \\ k - 2, \\ \\dots1, 2, 3, 4, …,k, k−1, k−2, … 为长度为 nnn 的数组，其中逆序对的个数为 ppp； 求一个字典序最大的 kkk 的排列，使得这个排列的逆序对数 ≤p\\le p≤p; Analysis 思维 对于原排列逆序对数为 k(k−1)2\\dfrac{k(k - 1)}{2}2k(k−1)​ 可能产生逆序对的排列为 a2k−n, …,ak, …,ana_{2k - n}, \\ \\dots, a_k, \\ \\dots, a_na2k−n​, …,ak​, …,an​ 共 n−k+1n - k + 1n−k+1 个数，2n−2k+12n - 2k + 12n−2k+1 个位置； 考虑交换 i, j (i&lt;2k−n, j≥2k−n)i, \\ j \\ (i &lt; 2k - n, \\ j \\ge 2k - n)i, j (i&lt;2k−n, j≥2k−n)，此时新排列产生的数组的逆序对数必然比原排列多； 故无法将原排列 a1, …, a2k−n−1a_1, \\ \\dots, \\ a_{2k - n - 1}a1​, …, a2k−n−1​ 中的数改变位置； 考察剩余产生逆序对的排列部分，将其逆置后逆序对数不变，即为字典序最大的所求排列。 Code 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;int T;int n, k;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; k; if (n == k) &#123; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; continue; &#125; int tmp = 0; for (int i = 1; i &lt; 2 * k - n; ++i) &#123; cout &lt;&lt; (++tmp) &lt;&lt; &quot; &quot;; &#125; tmp = k; for (int i = 2 * k - n; i &lt;= k; ++i) &#123; cout &lt;&lt; (tmp--) &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; D. Program 传送门 Problem 对初值为 000 的整型变量，有如下两种操作： +\\texttt{+}+：数值 +1+1+1 -\\texttt{-}-：数值 −1-1−1 给定长度为 nnn 的操作序列 sss； mmm 次询问，对于给定区间 [l, r][l, \\ r][l, r]，求区间外按序操作过程中能得到几种不同的值。 Analysis 思维 对于任意一组操作序列，变量 ppp 在整数域内是连续的； 因此，只需要计算区间 [1, l−1][1, \\ l - 1][1, l−1] 与 [r+1, n][r + 1, \\ n][r+1, n] 上变化量的最大值与最小值； 显然，对于区间一只需要顺序遍历数组，即可维护区间 [1, i][1, \\ i][1, i] 上的变化量最值； 对于区间 [j, n][j, \\ n][j, n]，我们将区间置逆，对于区间 [j+1, n][j + 1, \\ n][j+1, n] 上最大值 max⁡j+1\\max_{j+1}maxj+1​ 最小值 min⁡j−1\\min_{j-1}minj−1​，进行操作 sjs_jsj​，可得： 最大值：若 sjs_jsj​ 为 +\\texttt{+}+，则最大值为 max⁡j=max⁡j+1+1\\max_{j} = \\max_{j+1} + 1maxj​=maxj+1​+1；否则 max⁡j=max⁡(max⁡j+1−1,0)\\max_{j} = \\max(\\max_{j+1} - 1, 0)maxj​=max(maxj+1​−1,0) 最小值同理； 计算两端区间上的最值差即为答案。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &quot;\\n&quot;const int MAXN = 2e5 + 7;int T;string s;int n, m;int l, r;int val[MAXN];int premax[MAXN], premin[MAXN];int sufmax[MAXN], sufmin[MAXN];int ans;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; cin &gt;&gt; s; val[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; int tmp = (s[i - 1] == &#x27;+&#x27;) ? 1 : -1; val[i] = val[i - 1] + tmp; &#125; premax[0] = 0; premin[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; premax[i] = max(premax[i - 1], val[i]); premin[i] = min(premin[i - 1], val[i]); &#125; sufmax[n + 1] = 0; sufmin[n + 1] = 0; for (int i = n; i; --i) &#123; int tmp = (s[i - 1] == &#x27;+&#x27;) ? 1 : -1; sufmax[i] = max(0, sufmax[i + 1] + tmp); sufmin[i] = min(0, sufmin[i + 1] + tmp); &#125; while (m--) &#123; cin &gt;&gt; l &gt;&gt; r; int minl, maxl; int minr, maxr; minl = premin[l - 1]; maxl = premax[l - 1]; minr = val[l - 1] + sufmin[r + 1]; maxr = val[l - 1] + sufmax[r + 1]; ans = max(maxl, maxr) - min(minl, minr) + 1; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; E. Minimum Path 传送门 Problem 带权无环无向图，nnn 个顶点 mmm条边； 定义路径距离为 d=∑i=1kwei−max⁡i=1kwei+min⁡i=1kweid = \\sum\\limits_{i = 1}^{k} w_{e_i} - \\max\\limits_{i = 1}^{k} w_{e_i} + \\min\\limits_{i = 1}^{k} w_{e_i}d=i=1∑k​wei​​−i=1maxk​wei​​+i=1mink​wei​​； 求顶点 111 到任一顶点 iii 的最短距离 ddd。 Analysis 最短路 (Dijkstra) 贪心 显然，对于一条最短路中删去最长的边、增加最短的边比删去任一边、增加任一边得到的路径权值要更小； 考虑点的状态 路径中未删边且未增边 路径中已删边 路径中已增边 路径中已删边且已增边 考虑边的状态 普通边 删除的边 增加的边 删除且增加的边 建图 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;using namespace std;#define int long long#define endl &quot;\\n&quot;const int MAXN = 2e5 + 7;const int MAXE = 2e5 + 7;struct DijkstraPQ&#123; // Shortest Path in Non-negtive Directed Graph // Edge in Undirected Graph should add twice // Time Complexity: O(ElogE) struct Edge &#123; int nxt; int to; int val; &#125;edge[MAXE * 20]; int cntEdge; int head[MAXN * 4]; void init() &#123; cntEdge = 0; memset(head, 0, sizeof(head)); &#125; void addEdge(int u, int v, int w) &#123; cntEdge++; edge[cntEdge].nxt = head[u]; edge[cntEdge].to = v; edge[cntEdge].val = w; head[u] = cntEdge; &#125; int s; // start pos int n, m; // num of Nodes &amp;&amp; num of Edges int dis[MAXN * 4]; // dis from s to each node void dijkstra() &#123; memset(dis, 0x3f, sizeof(dis)); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; que; que.push(&#123;0, s&#125;); dis[s] = 0; while (!que.empty()) &#123; int now = que.top().second; int nowval = que.top().first; que.pop(); if (nowval &gt; dis[now]) continue; for (int i = head[now]; i; i = edge[i].nxt) &#123; int nxt = edge[i].to; int nxtval = edge[i].val; if (nxtval + dis[now] &lt; dis[nxt]) &#123; dis[nxt] = dis[now] + nxtval; que.push(&#123;dis[nxt], nxt&#125;); &#125; &#125; &#125; &#125;#ifdef DEBUG void showDis() &#123; cout &lt;&lt; s &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; dis[i] &lt;&lt; &quot; &quot;; &#125; &#125;#endif&#125;dij;int n, m;int u, v, w;int32_t main(void)&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; dij.init(); dij.s = 1; dij.n = 4 * n; dij.m = 4 * m; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; // normal edge dij.addEdge(u, v, w); dij.addEdge(v, u, w); dij.addEdge(n + u, n + v, w); dij.addEdge(n + v, n + u, w); dij.addEdge(2 * n + u, 2 * n + v, w); dij.addEdge(2 * n + v, 2 * n + u, w); dij.addEdge(3 * n + u, 3 * n + v, w); dij.addEdge(3 * n + v, 3 * n + u, w); // is max edge dij.addEdge(u, n + v, 0); dij.addEdge(v, n + u, 0); // is min edge dij.addEdge(u, 2 * n + v, 2 * w); dij.addEdge(v, 2 * n + u, 2 * w); // is max &amp;&amp; min edge dij.addEdge(u, 3 * n + v, w); dij.addEdge(v, 3 * n + u, w); // has min edge, is max edge dij.addEdge(2 * n + u, 3 * n + v, 0); dij.addEdge(2 * n + v, 3 * n + u, 0); // has max edge, is min edge dij.addEdge(n + u, 3 * n + v, 2 * w); dij.addEdge(n + v, 3 * n + u, 2 * w); &#125; dij.dijkstra(); for (int i = 3 * n + 2; i &lt;= 4 * n; ++i) &#123; cout &lt;&lt; dij.dis[i] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://noginonoka.github.io/tags/Graph-Theory/"},{"name":"Minimum Path","slug":"Minimum-Path","permalink":"https://noginonoka.github.io/tags/Minimum-Path/"}]}],"categories":[{"name":"Contest","slug":"Contest","permalink":"https://noginonoka.github.io/categories/Contest/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://noginonoka.github.io/categories/Algorithm/"},{"name":"Tittle-Tattle","slug":"Tittle-Tattle","permalink":"https://noginonoka.github.io/categories/Tittle-Tattle/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://noginonoka.github.io/tags/Codeforces/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://noginonoka.github.io/tags/Dynamic-Programming/"},{"name":"Graph Theory","slug":"Graph-Theory","permalink":"https://noginonoka.github.io/tags/Graph-Theory/"},{"name":"Network Flow","slug":"Network-Flow","permalink":"https://noginonoka.github.io/tags/Network-Flow/"},{"name":"Template","slug":"Template","permalink":"https://noginonoka.github.io/tags/Template/"},{"name":"ICPC","slug":"ICPC","permalink":"https://noginonoka.github.io/tags/ICPC/"},{"name":"Memory Search","slug":"Memory-Search","permalink":"https://noginonoka.github.io/tags/Memory-Search/"},{"name":"Greedy","slug":"Greedy","permalink":"https://noginonoka.github.io/tags/Greedy/"},{"name":"ACGN","slug":"ACGN","permalink":"https://noginonoka.github.io/tags/ACGN/"},{"name":"Math Theory","slug":"Math-Theory","permalink":"https://noginonoka.github.io/tags/Math-Theory/"},{"name":"Probability Theory","slug":"Probability-Theory","permalink":"https://noginonoka.github.io/tags/Probability-Theory/"},{"name":"Minimum Path","slug":"Minimum-Path","permalink":"https://noginonoka.github.io/tags/Minimum-Path/"}]}